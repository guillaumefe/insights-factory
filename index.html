<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>!nsight-Factory — Builder de modèle</title>
<script src="https://cdn.jsdelivr.net/npm/@zip.js/zip.js@2.7.48/dist/zip.min.js"></script>
<style>
/* ============ Thème clair + base ============ */
:root{
  --bg:#f6f7fb;
  --panel:#ffffff;
  --panel-2:#fafafa;
  --muted:#6b7280;
  --fg:#111827;

  --accent:#2563eb;     /* bleu */
  --accent-2:#14b8a6;   /* teal */
  --danger:#dc2626;
  --ok:#16a34a;

  --card-border:#e5e7eb;
  --shadow:0 6px 18px rgba(17,24,39,.08);
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font:15px/1.6 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  color:var(--fg);
  background:var(--bg);
}

/* ============ En-tête ============ */
header{
  position:sticky; top:0; z-index:50;
  padding:12px clamp(12px,4vw,24px);
  border-bottom:1px solid var(--card-border);
  backdrop-filter:saturate(130%) blur(6px);
  background:rgba(255,255,255,.9);
  display:grid; grid-template-columns:auto 1fr; gap:12px; align-items:center;
}
header h1{margin:0; font-size:16px; font-weight:800; color:#0f172a}
header h1 .brand{color:var(--accent)}
.toolbar{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-start}

/* ============ Boutons ============ */
button,.btn{
  border:1px solid var(--card-border);
  background:var(--panel);
  color:var(--fg);
  padding:10px 12px;
  border-radius:10px;
  cursor:pointer;
  transition:background .15s ease, transform .05s ease, border-color .15s ease, box-shadow .15s ease;
}
button:hover{background:#f3f4f6}
button:active{transform:translateY(1px)}
button:focus-visible{outline:2px solid var(--accent); outline-offset:2px}

.primary{background:var(--accent); border-color:var(--accent); color:#fff; font-weight:700}
.primary:hover{filter:brightness(0.95)}
.danger{background:#fee2e2; border-color:#fecaca; color:#991b1b}
.danger:hover{background:#fecaca}
.ok{background:#dcfce7; border-color:#bbf7d0; color:#166534}
.ok:hover{background:#bbf7d0}
.ghost{background:transparent}
.icon{font-style:normal; opacity:.9; margin-right:6px}

/* ============ Champs de formulaire ============ */
input[type="text"],input[type="number"],select,textarea{
  width:100%;
  padding:10px 12px;
  border:1px solid var(--card-border);
  background:var(--panel);
  color:var(--fg);
  border-radius:10px;
  outline:none;
}
input:focus,select:focus,textarea:focus{
  border-color:var(--accent);
  box-shadow:0 0 0 3px rgba(37,99,235,.12);
}
textarea{min-height:90px; resize:vertical; white-space:pre-wrap}

/* ============ Layout & panneaux ============ */
.wrap{
  display:grid;
  grid-template-columns:1fr;
  gap:12px;
  padding:12px;
}
.panel{
  background:var(--panel);
  border:1px solid var(--card-border);
  border-radius:14px;
  padding:14px;
  box-shadow:var(--shadow);
}
.panel h2{
  margin:2px 0 10px 0;
  font-size:13px;
  color:#334155;
  font-weight:600;
  letter-spacing:.2px;
}

@media (min-width:1100px){
  .wrap{grid-template-columns:360px 1fr; gap:16px; padding:16px}
  header{grid-template-columns:auto 1fr; gap:18px}
  .toolbar{justify-content:flex-start}
}

/* ============ Listes & cartes ============ */
.list,.fields{display:flex; flex-direction:column; gap:8px}

.proc-item,.section-item,.field-item{
  border:1px solid var(--card-border);
  background:var(--panel);
  padding:10px;
  border-radius:12px;
  display:flex; gap:10px; align-items:center;
  transition:background .15s ease, border-color .15s ease, box-shadow .15s ease;
}
.proc-item:hover,.section-item:hover,.field-item:hover{
  background:var(--panel-2);
  border-color:#d1d5db;
}
.proc-item .title,.section-item .title{flex:1; font-weight:700}
.field-item .meta{flex:1}

.drag{cursor:grab; color:#94a3b8}
.proc-item.dragging,.section-item.dragging,.field-item.dragging{opacity:.6; outline:2px dashed #93c5fd}
.proc-item.disabled{opacity:.5; filter:saturate(.7)}

/* ============ Grilles (lignes de formulaire) ============ */
.row{display:grid; grid-template-columns:1fr; gap:8px}
.row3{display:grid; grid-template-columns:1fr; gap:8px}
@media (min-width:720px){
  .row{grid-template-columns:1fr 1fr}
  .row3{grid-template-columns:2fr 1fr 1fr}
}

/* ============ Utilitaires ============ */
.muted{color:var(--muted)}
.pill{
  font-size:12px; padding:2px 8px; border-radius:999px;
  background:#f3f4f6; border:1px solid var(--card-border); color:#374151
}
.right{margin-left:auto; display:flex; gap:6px; flex-wrap:wrap}
.hr{height:1px; background:var(--card-border); margin:10px 0}
.preview pre{
  margin:0; padding:10px; background:#f8fafc;
  border:1px solid var(--card-border); border-radius:10px; color:#111827;
  overflow:auto; max-height:40vh; font-size:13px; line-height:1.5;
}
.inline{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
.hidden{display:none !important}
.fab{
  position:fixed; right:16px; bottom:16px; z-index:60;
  padding:12px 14px; border-radius:999px; border:1px solid var(--accent);
  background:var(--accent); color:#fff; box-shadow:var(--shadow)
}
.toast{
  position:fixed; left:50%; bottom:24px; transform:translateX(-50%) translateY(20px);
  opacity:0; pointer-events:none; background:#111827; color:#fff;
  border:1px solid rgba(255,255,255,.08); padding:10px 12px; border-radius:12px;
  transition:.2s ease; z-index:70; font-size:13px
}
.toast.show{opacity:1; transform:translateX(-50%) translateY(0)}
.sticky-add{
  position:sticky; bottom:0; padding:10px 0 0 0; margin-top:10px;
  background:linear-gradient(180deg, rgba(255,255,255,0), rgba(255,255,255,.95));
  backdrop-filter:saturate(140%) blur(4px); border-top:1px solid var(--card-border)
}
.sticky-add .btn{width:100%}

/* ============ Groupes (conteneurs de champs) ============ */
.group-item{
  border:1px solid var(--card-border);
  background:#ffffff;
  padding:10px; border-radius:12px;
}
.group-head{display:flex; align-items:center; gap:10px}
.group-title{font-weight:800}
.group-meta{color:#475569}
.group-fields{
  display:flex; flex-direction:column; gap:8px; margin-top:8px;
  padding:8px; border:1px dashed #cbd5e1; border-radius:10px; background:#f8fafc
}
.select-box{margin-right:6px}

/* ============ DnD (surbrillance de drop) ============ */
.drop-target{outline:2px dashed var(--accent); outline-offset:2px}
.drop-before{border-top:2px solid var(--accent)}

/* ============ Tips (astuces de champ) ============ */
.tip-editor{
  background:var(--panel-2);
  border:1px dashed var(--card-border);
  border-radius:12px;
  padding:12px;
}
.tip-toolbar{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:8px}
.tip-preview{
  margin-top:10px;
  display:flex; gap:10px; align-items:flex-start;
  background:#f8fafc;
  border:1px solid var(--card-border);
  border-radius:10px;
  padding:10px;
  min-height:44px;
  color:var(--fg);
  white-space:normal;
}
.tip-preview .tip-icon{
  font-size:24px; line-height:1; width:28px; text-align:center; flex:0 0 28px;
}
.tip-preview .tip-text a{
  text-decoration:underline;
  word-break:break-word;
}

/* ============ Icon picker ============ */
.icon-picker{
  position:relative;
}
.icon-grid{
  position:absolute; top:100%; left:0; margin-top:6px;
  background:#fff; border:1px solid var(--card-border); border-radius:12px;
  box-shadow:var(--shadow);
  padding:8px; display:grid; grid-template-columns:repeat(8, 28px); gap:6px;
  width:max-content; max-width:320px; z-index:40;
}
.icon-grid button{
  width:28px; height:28px; border:1px solid #e5e7eb; border-radius:8px; background:#fff; cursor:pointer;
  font-size:18px; line-height:1; display:flex; align-items:center; justify-content:center;
}
.icon-grid button:hover{background:#f3f4f6}
.icon-grid.hidden{display:none}

/* ============ États d'accessibilité ============ */
button[disabled], .btn[disabled]{opacity:.6; cursor:not-allowed}

/* ===== Modales (mot de passe / avertissement) ===== */
.modal-backdrop{
  position:fixed; inset:0; background:rgba(0,0,0,.35);
  display:none; align-items:center; justify-content:center; z-index:90;
}
.modal{
  width:min(520px, 92vw); background:var(--panel); border:1px solid var(--card-border);
  border-radius:14px; box-shadow:var(--shadow); padding:16px;
}
.modal h3{ margin:0 0 8px; font-size:16px }
.modal p{
  margin:4px 0 10px;
  color:var(--muted);
  white-space:pre-line; /* ← permet d’afficher \n \n */
}
.modal .row{ display:flex; gap:8px; align-items:center }
.modal .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:12px }
.modal input[type="password"], .modal input[type="text"]{ width:100% }
.modal-backdrop.show{ display:flex }

/* Anti-overflow global pour les layouts flex/grid */
* { box-sizing: border-box; min-width: 0 }

/* Conteneur central fluide, évite l'étirement hors écran */
.wrap{
  display:grid;
  grid-template-columns:1fr;
  gap:12px;
  padding:12px;
  width: min(1200px, 100%);
  margin-inline: auto;
}

/* Empêche les éléments flex de forcer l'élargissement */
.inline, .toolbar, header { min-width: 0 }

/* Les panels ne débordent pas et peuvent scroller si besoin */
.panel { overflow: hidden }

/* Les listes prennent bien la largeur dispo sans pousser le grid */
.list,.fields { min-width: 0 }

/* Le header s’adapte mieux sur petits écrans */
.toolbar{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-start; min-width:0}

/* Préservation de l’aperçu sans déborder horizontalement */
.preview pre{ max-width:100%; overflow:auto }

@media (min-width:1100px){
  /* Empêche le scroll global ; on scrollera à l’intérieur des colonnes */
  html, body { height:100%; overflow:hidden; }

  /* 2 colonnes plein écran sous le header */
  .wrap{
    grid-template-columns: 360px 1fr;     /* colonne gauche fixe */
    height: calc(100vh - var(--header-h, 64px)); /* remplit l’écran dispo */
    overflow: hidden;                     /* pas de débordement horizontal */
  }

  /* Colonne gauche = pile de panneaux scrollables */
  .left-col{
    display:flex; flex-direction:column; gap:16px;
    min-height:0; overflow:hidden;
  }
  .left-col .panel{
    flex:1; min-height:0; overflow:auto; /* chaque panel peut scroller si long */
  }

  /* Panneau de droite occupe toute la hauteur et scrolle en interne */
  .main-panel{
    height:100%; min-height:0; overflow:auto;
    display:block;
  }

  /* Sécurité anti-débordement horizontal */
  .panel, .list, .fields, .inline, header { min-width:0 }
  .preview pre{ max-width:100%; overflow:auto }
}
/* 1) Empêcher le chevauchement : le titre peut rétrécir et couper en ellipsis */
.proc-item .title,
.section-item .title{
  flex: 1 1 auto;       /* laisse la place à la pill */
  min-width: 0;         /* indispensable en flexbox pour autoriser le shrink */
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/* 2) La pill reste compacte et ne wrap pas; pas de retour à la ligne du container */
.proc-item,
.section-item{
  flex-wrap: nowrap;    /* pas de saut de ligne dans la carte */
}
.proc-item .pill,
.section-item .pill{
  flex: 0 0 auto;       /* taille intrinsèque, pas de flex-shrink */
  margin-left: 8px;     /* un peu d’air entre titre et pill */
}

/* Afficher les titres complets dans le panneau gauche en mode écran */
@media (min-width:1100px){
  /* Les cartes peuvent passer sur 2 lignes si besoin */
  .proc-item,
  .section-item{
    align-items: flex-start;
    flex-wrap: wrap;              /* autorise le retour à la ligne */
  }

  /* Le titre prend toute la largeur disponible et peut se couper */
  .proc-item .title,
  .section-item .title{
    flex: 1 1 100%;
    min-width: 0;
    white-space: normal;          /* plus de nowrap */
    overflow: visible;            /* plus d’ellipse */
    text-overflow: clip;
    word-break: break-word;       /* évite les débordements sur mots longs */
  }

  /* La pastille et les boutons passent à la ligne si nécessaire */
  .proc-item .pill,
  .section-item .pill{
    flex: 0 0 auto;
    margin-left: 0;
    margin-top: 4px;
  }

  .proc-item .right,
  .section-item .right{
    flex: 0 0 100%;               /* groupe de boutons sur la ligne suivante */
    justify-content: flex-end;
    gap: 6px;
    margin-left: 0;
    margin-top: 6px;
  }
}

.field-item.editing, .group-item.editing{
  outline:2px solid var(--accent-2);
  background: var(--panel-2);
}
</style>
</head>
<body>
  <header>
    <div class="inline">
      <h1><span class="brand">!nsight-Factory</span></h1>
    </div>
    <div class="toolbar">
      <label class="btn ghost inline" for="fileImport" style="cursor:pointer"><span class="icon">📥</span>Importer la mémoire</label>
      <input id="fileImport" type="file" accept="application/json,.json" class="hidden">
      <button class="btn" id="btnExport"><span class="icon">💾</span>Exporter la mémoire</button>
      <button class="btn primary" id="btnCopy"><span class="icon">📋</span>Copier le JSON</button>
      <button class="btn" id="btnProcZip"><span class="icon">🗃️</span>Exporter le processus (ZIP)</button>
      <button class="btn" id="btnUmlZip"><span class="icon">🧩</span>Exporter les schéma UML (ZIP)</button>
    </div>
  </header>

  <div class="wrap">
    <div class="left-col">
      <div class="panel">
        <h2>Processus</h2>
        <div id="processList" class="list" aria-label="Liste des processus"></div>
        <div class="hr"></div>
        <div class="inline" style="justify-content:space-between">
          <div class="muted">Glissez pour réordonner. Activez/Désactivez pour inclure/retirer du JSON.</div>
          <button class="btn ok" id="btnNewProcess"><span class="icon">➕</span>Nouveau processus</button>
        </div>
      </div>

      <div class="panel">
        <h2>Parties (sections) du processus actif</h2>
        <div id="sectionList" class="list" aria-label="Liste des sections"></div>
        <div class="hr"></div>
        <div class="inline" style="justify-content:space-between">
          <div class="muted">Glissez pour réordonner. Cliquez pour éditer.</div>
          <button class="btn" id="btnNewSection"><span class="icon">➕</span>Nouvelle partie</button>
        </div>
      </div>
    </div>

    <!-- >>> Panneau de droite scrollable -->
    <div class="panel main-panel">
      <div id="processEditor" class="hidden" aria-live="polite">
        <h2>Édition du processus</h2>
        <div class="row" style="margin-bottom:8px">
          <div>
            <label class="small">Nom du processus</label>
            <input id="procName" type="text" placeholder="Ex: Processus d’inscription">
          </div>
        </div>
        <div class="hr"></div>
      </div>

      <h2 id="editorTitle" class="muted">Aucune partie sélectionnée</h2>

      <div id="editorArea" class="hidden" aria-live="polite">
        <div class="row">
          <div>
            <label class="small">Titre de la partie</label>
            <input id="secTitle" type="text" placeholder="Ex: Informations générales">
          </div>
          <div class="inline" style="align-items:end; justify-content:flex-end">
            <button class="btn danger" id="btnDeleteSection">Supprimer la partie</button>
          </div>
        </div>

        <div class="hr"></div>

        <div class="row3">
          <div><label class="small">Nom du champ</label><input id="fldName" type="text" placeholder="Saisir le libellé du champ"></div>
          <div>
            <label class="small">Type</label>
            <select id="fldType">
              <option value="text">text</option>
              <option value="textarea">textarea</option>
              <option value="number">number</option>
              <option value="date">date</option>
              <option value="checkbox">checkbox</option>
              <option value="radio">radio</option>
              <option value="select">select</option>
              <option value="file">file</option>
            </select>
          </div>
          <div><label class="small">Label (apercu)</label><input id="fldLabel" type="text" placeholder="Reprend exactement le 'Nom du champ'"></div>
        </div>
        <div class="row">
          <div>
            <label class="small">Obligatoire ?</label>
            <select id="fldRequired"><option value="false">Non</option><option value="true">Oui</option></select>
          </div>
          <div>
            <label class="small">Répétable ?</label>
            <select id="fldRepeatable"><option value="false">Non</option><option value="true">Oui</option></select>
          </div>
        </div>
        <div class="row" id="rowOptions" style="margin-top:8px">
          <div>
            <label class="small">Options (radio/select) — séparées par des virgules</label>
            <input id="fldOptions" type="text" placeholder="Oui, Non">
          </div>
          <div class="inline" style="align-items:end; justify-content:flex-end">
            <button class="btn ok" id="btnAddFieldTop"><span class="icon">➕</span>Ajouter un champ</button>
          </div>
        </div>

        <!-- Tips (astuces) -->
        <div class="hr"></div>
        <div class="tip-editor">
          <div class="muted">Astuce (facultatif) — texte riche (liens auto) + grosse icône. Le texte peut être <strong>multiligne</strong>.</div>

          <div class="tip-toolbar">
            <div class="icon-picker">
              <button class="btn" id="btnToggleIconPicker" type="button">🎯 Choisir une icône</button>
              <div id="iconGrid" class="icon-grid hidden" role="dialog" aria-label="Choisir une icône"></div>
            </div>

            <div style="min-width:240px; flex:1">
              <label class="small">Icône (libre ou via la grille) — emoji/texte</label>
              <input id="fldTipsIcon" type="text" placeholder="Ex: 💡, 📎, ℹ️" maxlength="8" list="iconDatalist">
              <datalist id="iconDatalist"></datalist>
            </div>
          </div>

          <div style="margin-top:8px">
            <label class="small">Texte de l’astuce (liens reconnus ; retours à la ligne conservés)</label>
            <textarea id="fldTips" placeholder="Ex: 1) Consultez https://docs.exemple.com\n2) Écrivez à support@exemple.com"></textarea>
          </div>

          <div class="tip-preview" id="fldTipsPreview" aria-live="polite"></div>
        </div>

        <div class="inline" style="gap:8px; margin:6px 0 2px">
          <button class="btn ok" id="btnAddGroup"><span class="icon">🗂️</span>Nouveau groupe</button>
          <button class="btn" id="btnGroupSelected"><span class="icon">📦</span>Grouper la sélection</button>
        </div>

        <div class="hr"></div>
        <div class="inline" style="justify-content:space-between">
          <div class="muted">Champs et groupes de cette partie</div>
          <div class="inline">
            <button class="btn" id="btnFieldUp" title="Monter l’élément en édition">⬆️</button>
            <button class="btn" id="btnFieldDown" title="Descendre l’élément en édition">⬇️</button>
          </div>
        </div>
        <div id="fieldList" class="fields" aria-label="Items de la section"></div>
        <div class="sticky-add">
          <button class="btn ok" id="btnAddFieldSticky"><span class="icon">➕</span>Ajouter un champ</button>
        </div>

        <div id="groupEditor" class="hidden" style="margin-top:10px">
          <div class="hr"></div>
          <div class="inline" style="justify-content:space-between">
            <div class="muted">Édition du groupe</div>
            <button class="btn danger" id="btnDeleteGroup">Supprimer le groupe</button>
          </div>
          <div class="row3" style="margin-top:8px">
            <div><label class="small">Nom technique</label><input id="grpName" type="text" placeholder="auto: ultra-court"></div>
            <div><label class="small">Label</label><input id="grpLabel" type="text" placeholder="Label du groupe"></div>
            <div class="inline" style="gap:8px">
              <div style="flex:1">
                <label class="small">Obligatoire ?</label>
                <select id="grpRequired"><option value="false">Non</option><option value="true">Oui</option></select>
              </div>
              <div style="flex:1">
                <label class="small">Répétable ?</label>
                <select id="grpRepeatable"><option value="false">Non</option><option value="true">Oui</option></select>
              </div>
            </div>
          </div>
          <div class="inline" style="justify-content:flex-end; margin-top:8px">
            <button class="btn ok" id="btnAddFieldInGroup"><span class="icon">➕</span>Ajouter un champ dans ce groupe</button>
          </div>
        </div>
      </div>

      <div class="hr"></div>
      <div class="preview">
        <div class="inline" style="justify-content:space-between; margin-bottom:6px">
          <div class="muted">Aperçu JSON (live) — seuls les processus <strong>activés</strong> sont exportés</div>
          <div>
            <span class="pill" id="countProcesses">0 processus</span>
            <span class="pill" id="countSections">0 parties</span>
            <span class="pill" id="countFields">0 items</span>
          </div>
        </div>
        <pre id="jsonPreview">[]</pre>
      </div>
    </div>
  </div>

  <button class="fab primary" id="fabAdd"><span class="icon">➕</span>Processus</button>
  <div id="toast" class="toast" role="status" aria-live="polite"></div>

<!-- Modale générique -->
<div id="modalHost" class="modal-backdrop" role="dialog" aria-modal="true">
  <div class="modal" role="document">
    <h3 id="modalTitle">Titre</h3>
    <p id="modalText">Texte</p>
    <div id="modalInputRow" class="row hidden">
      <input id="modalInput" type="password" placeholder="Mot de passe" autocomplete="current-password">
    </div>
    <div class="actions">
      <button class="btn" id="modalCancel">Annuler</button>
      <button class="btn primary" id="modalOk">OK</button>
    </div>
  </div>
</div>

<!-- =========================
     PARTIE 1/3 — ÉTAT & HELPERS
     ========================= -->
<script>
/* --- État global --- */
let PROCESSES = [];
let currentProcess = 0;
let currentSection = -1;
let editingFieldIndex = -1;
let editingGroupIndex = -1;

const DND_MIME = 'application/x-json-item';

const $  = (sel, root=document)=> root.querySelector(sel);
const $$ = (sel, root=document)=> [...root.querySelectorAll(sel)];
const save = ()=> localStorage.setItem('templateBuilderV2', JSON.stringify(PROCESSES));
const load = ()=> { try{ const raw = localStorage.getItem('templateBuilderV2'); return raw ? JSON.parse(raw) : []; }catch(_){ return []; } };
const isOptType = t => (t==='radio' || t==='select');
const isField = o => o && o.__kind === 'field';
const isGroup = o => o && o.__kind === 'group';
const P = ()=> PROCESSES[currentProcess] || null;
const S = ()=> (P()?.sections) || [];
const hasType = (dt, t)=> Array.from(dt?.types || []).indexOf(t) !== -1;

function toast(msg){ const t=$('#toast'); if(!t) return; t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1200); }

/* UID groupes */
let __gid_inc = 1;
function genUid(){ try{ return crypto.randomUUID(); }catch(_){ return 'g'+(__gid_inc++); } }

/* Base64 util (binaire-sûr) */
function b64encode(u8){ let s='',c=0x8000; for(let i=0;i<u8.length;i+=c){ s+=String.fromCharCode.apply(null,u8.subarray(i,i+c)); } return btoa(s); }
function b64decode(b){ const bin=atob(b); const u8=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i); return u8; }

/* Modale accessible (Esc, trap focus) */
function openModal({title, text, password=false, placeholder='Mot de passe', okText='OK'}){
  return new Promise(resolve=>{
    const host = $('#modalHost');
    const t = $('#modalTitle'); const p = $('#modalText');
    const row = $('#modalInputRow'); const inp = $('#modalInput');
    const ok = $('#modalOk'); const cancel = $('#modalCancel');
    const prevFocus = document.activeElement;

    t.textContent = title||''; p.textContent = text||'';
    row.classList.toggle('hidden', !password);
    inp.type = password ? 'password' : 'text'; inp.value = ''; inp.placeholder = placeholder;
    ok.textContent = okText;

    function close(val){
      host.classList.remove('show');
      document.removeEventListener('keydown', onKey);
      if (prevFocus && prevFocus.focus) prevFocus.focus();
      resolve(val);
    }
    function onKey(e){
      if (e.key === 'Escape'){ e.preventDefault(); close(null); }
      if (e.key === 'Tab'){
        const foci = host.querySelectorAll('button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])');
        if (!foci.length) return;
        const first = foci[0], last = foci[foci.length-1];
        if (e.shiftKey && document.activeElement === first){ e.preventDefault(); last.focus(); }
        else if (!e.shiftKey && document.activeElement === last){ e.preventDefault(); first.focus(); }
      }
    }
    ok.onclick=()=> close(password ? inp.value : true);
    cancel.onclick=()=> close(null);
    document.addEventListener('keydown', onKey);
    host.classList.add('show');
    setTimeout(()=> (password ? inp : ok).focus(), 0);
  });
}
const promptPassword = (title='Mot de passe requis', text='Saisissez le mot de passe.') => openModal({title,text,password:true,okText:'Valider'});
const confirmWarning = (title, text, okText='Oui, continuer') => openModal({title,text,password:false,okText});

/* WebCrypto: PBKDF2 + AES-GCM */
async function deriveAesKey(password, saltU8, iterations=200000){
  const enc = new TextEncoder();
  const baseKey = await crypto.subtle.importKey('raw', enc.encode(password), {name:'PBKDF2'}, false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    {name:'PBKDF2', salt: saltU8, iterations, hash:'SHA-256'},
    baseKey,
    {name:'AES-GCM', length:256},
    false, ['encrypt','decrypt']
  );
}
async function aesGcmEncryptFromString(password, plain){
  const enc = new TextEncoder();
  const data = enc.encode(plain);
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv   = crypto.getRandomValues(new Uint8Array(12));
  const key  = await deriveAesKey(password, salt);
  const ct   = new Uint8Array(await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, data));
  return { format:'IF-AESGCM-v1', kdf:'PBKDF2', hash:'SHA-256', iter:200000, salt:b64encode(salt), iv:b64encode(iv), ct:b64encode(ct) };
}
async function aesGcmDecryptToString(password, pack){
  if (!pack || pack.format!=='IF-AESGCM-v1') throw new Error('Format inconnu');
  const salt=b64decode(pack.salt), iv=b64decode(pack.iv), ct=b64decode(pack.ct);
  const key=await deriveAesKey(password, salt, pack.iter||200000);
  const pt=new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ct));
  return new TextDecoder().decode(pt);
}

/* tinyName + uniqueName (fallback sans \p{Diacritic} si non supporté) */
function stripDiacritics(s){
  try{ return s.normalize('NFD').replace(/\p{Diacritic}/gu,''); }
  catch(_){ return s.normalize('NFD').replace(/[\u0300-\u036f]/g,''); }
}
function tinyName(str, max=6){
  if (!str) return 'i';
  let s = stripDiacritics(String(str)).toLowerCase().replace(/[^a-z0-9\s]/g,' ').trim();
  if (!s) return 'i';
  const words = s.split(/\s+/).filter(Boolean);
  let out = words.map(w=>w[0]).join('');
  if (out.length<2){ const w=words[0]||s; const cons=w.replace(/[aeiou]/g,''); out=(w[0]||'')+(cons.slice(1)||w.slice(1)); }
  if (out.length<2) out = s.replace(/\s+/g,'');
  out = out.slice(0,max);
  return out || 'i';
}
function uniqueName(base){
  const used = new Set();
  S().forEach(sec=>{
    (sec.fields||[]).forEach(it=>{
      if (isGroup(it) && it.name) used.add(it.name);
      if (isField(it) && it.name) used.add(it.name);
      if (isGroup(it)) (it.fields||[]).forEach(f=>{ if (f.name) used.add(f.name); });
    });
  });
  let name = base || 'i';
  if (!used.has(name)) return name;
  let n=2; while(used.has(`${name}-${n}`)) n++;
  return `${name}-${n}`;
}

/* Fabriques */
function makeField(){ return { __kind:'field', name:'', type:'text', label:'', required:false, repeatable:false, options:[], nameAuto:true, tips:{icon:'',text:''} }; }
function makeGroup(){ return { __kind:'group', __uid:genUid(), name:'', label:'', required:false, repeatable:false, fields:[], nameAuto:true }; }
function makeSection(){ return { title:'Nouvelle partie', fields:[] }; }
function makeProcess(){ return { name:`Processus ${PROCESSES.length+1}`, enabled:true, sections:[] }; }

/* Linkify + multilignes (sécurisé) */
function linkifyRaw(text){
  if (!text) return '';
  let t = String(text)
    .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;').replace(/'/g,'&#39;');
  t = t.replace(/(\bhttps?:\/\/[^\s<]+)/gi, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
  t = t.replace(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g, '<a href="mailto:$1">$1</a>');
  t = t.replace(/\r?\n/g, '<br>');
  return t;
}

/* Construction DOM sans innerHTML non maîtrisé */
function el(tag, className, text){
  const e = document.createElement(tag);
  if (className) e.className = className;
  if (text != null) e.textContent = text;
  return e;
}

/* Wrap texte pour UML (sans mesure via canvas) — approx. par longueur */
function wrapByChars(s, maxChars){
  const words = String(s||'').split(/\s+/).filter(Boolean);
  const out=[]; let cur='';
  words.forEach(w=>{
    const t = cur ? cur+' '+w : w;
    if (t.length <= maxChars) cur = t; else { if (cur) out.push(cur); cur = w; }
  });
  if (cur) out.push(cur);
  return out.length ? out : [''];
}

// --- Deep clone robuste
function deepClone(obj){
  if (typeof structuredClone === 'function') return structuredClone(obj);
  return JSON.parse(JSON.stringify(obj));
}

// --- Renomme proprement un champ selon vos règles
function _renameFieldUnique(f){
  const base = tinyName(f.label || f.name || 'champ');
  f.name = uniqueName(base);
  f.nameAuto = false;
}

// --- Renomme proprement un groupe (+ uid neuf) et ses champs
function _renameGroupUnique(g){
  g.__uid = genUid();
  const base = tinyName(g.label || g.name || 'groupe');
  g.name = uniqueName(base);
  g.nameAuto = false;
  (g.fields || []).forEach(_renameFieldUnique);
}

// --- Renomme tous les items d’une section copiée
function _uniquifySectionItems(sec){
  (sec.fields || []).forEach(it=>{
    if (isGroup(it)) _renameGroupUnique(it);
    else _renameFieldUnique(it);
  });
}

// Dupliquer une section du process courant
function duplicateSection(procIdx, secIdx){
  const src = getSection(procIdx, secIdx);
  if (!src) return;
  const copy = deepClone(src);
  copy.title = (src.title || '(sans titre)') + ' (copie)';

  // Rendre les noms & uid uniques dans le contexte du process/section cibles
  const prevP = currentProcess, prevS = currentSection;
  currentProcess = procIdx; currentSection = secIdx;
  _uniquifySectionItems(copy);
  currentProcess = prevP; currentSection = prevS;

  const destIdx = secIdx + 1;
  PROCESSES[procIdx].sections.splice(destIdx, 0, copy);
  save(); renderAll(); selectProcess(procIdx); selectSection(destIdx);
  toast('Partie dupliquée ✅');
}

// Dupliquer un processus entier
function duplicateProcess(procIdx){
  const src = getProcess(procIdx);
  if (!src) return;
  const copy = deepClone(src);
  copy.name = (src.name || 'Processus') + ' (copie)';
  copy.enabled = src.enabled !== false;

  // uid neufs pour les groupes (utile pour DnD)
  (copy.sections || []).forEach(sec=>{
    (sec.fields || []).forEach(it=>{
      if (isGroup(it)) it.__uid = genUid();
    });
  });

  const destIdx = procIdx + 1;
  PROCESSES.splice(destIdx, 0, copy);
  save(); renderAll(); selectProcess(destIdx);
  toast('Processus dupliqué ✅');
}

</script>

<!-- =========================
     PARTIE 2/3 — RENDU & UI
     ========================= -->
<script>
/* --- Helpers de rendu d’astuce --- */
function updateTipsPreview(f){
  const prev = $('#fldTipsPreview'); if (!prev) return;
  const icon = (f.tips?.icon)||'';
  const text = (f.tips?.text)||'';
  prev.innerHTML = `
    <div class="tip-icon">${icon || '💡'}</div>
    <div class="tip-text">${linkifyRaw(text) || '<span class="muted">Aucune astuce</span>'}</div>
  `;
}

/* --- Rendu Processus / Sections (DOM sûr) --- */
function renderProcesses(){
  preservePanelScroll(() => {
  const list = $('#processList'); list.innerHTML = '';
  PROCESSES.forEach((proc, i)=>{
    const item = el('div', 'proc-item' + (proc.enabled ? '' : ' disabled'));
    item.draggable = true; item.dataset.index = i;

    const drag = el('div', 'drag', '⋮⋮'); drag.title = 'Glisser pour réorganiser';
    const title = el('div', 'title', proc.name || '(sans nom)');
    const pill = el('span', 'pill', `${(proc.sections||[]).length} partie(s)`);
    const right = el('div','right');

    const bToggle = el('button','btn', proc.enabled ? 'Désactiver' : 'Activer'); bToggle.dataset.act='toggle';
    const bEdit   = el('button','btn','Éditer'); bEdit.dataset.act='edit';
    const bDel    = el('button','btn danger','Supprimer'); bDel.dataset.act='del';
    const bDup   = el('button','btn','Dupliquer'); bDup.dataset.act='dup';
    right.append(bDup, bToggle, bEdit, bDel);

    item.append(drag,title,pill,right);
    if (i===currentProcess) item.style.outline='2px solid var(--accent-2)';

    item.addEventListener('click',(e)=>{
      const act = e.target.closest('button')?.dataset?.act || 'edit';
      if (act==='edit'){ selectProcess(i); $('#processEditor')?.scrollIntoView({behavior:'smooth'}); }
      else if (act==='dup'){ 
        duplicateProcess(i);
      }
      else if (act==='toggle'){ PROCESSES[i].enabled = !PROCESSES[i].enabled; save(); renderAll(); }
      else if (act==='del'){
        if (PROCESSES.length<=1){ toast('Au moins un processus est requis'); return; }
        if (confirm('Supprimer ce processus ?')){
          PROCESSES.splice(i,1);
          if (currentProcess>=PROCESSES.length) currentProcess=PROCESSES.length-1;
          currentSection=-1; save(); renderAll(); selectProcess(currentProcess);
        }
      }
    });

    item.addEventListener('dragstart',(e)=>{
      item.classList.add('dragging');
      e.dataTransfer.setData('text/plain', i);
      e.dataTransfer.effectAllowed='move';
    });
    item.addEventListener('dragend',()=> item.classList.remove('dragging'));

    item.addEventListener('dragover',(e)=>{
      const dt=e.dataTransfer;
      if (Array.from(dt.types||[]).length){ e.preventDefault(); item.classList.add('drop-target'); }
    });
    item.addEventListener('dragleave',()=> item.classList.remove('drop-target'));
    item.addEventListener('drop', async (e)=>{
      e.preventDefault(); item.classList.remove('drop-target');
      const dt=e.dataTransfer;
      const hasJson = hasType(dt, DND_MIME);
      const hasText = hasType(dt, 'text/plain');

      // Réordonnancement des processus
      if (hasText && !hasJson){
        const from = +dt.getData('text/plain'); const to=i;
        if (!Number.isInteger(from) || from===to) return;
        const [m]=PROCESSES.splice(from,1); PROCESSES.splice(to,0,m);
        currentProcess = to; save(); renderAll(); selectProcess(currentProcess); return;
      }

      // Dépôt d'une SECTION vers ce process
      if (hasJson){
        let payload; try{ payload = JSON.parse(dt.getData(DND_MIME)||'{}'); }catch(_){ return; }
        if (!payload || payload.kind!=='section') return;
        const fromProc=payload.proc, fromSec=payload.sec, toProc=i;
        if (!PROCESSES[fromProc]?.sections?.[fromSec]) return;
        if (fromProc !== toProc){
          const secTitle = PROCESSES[fromProc].sections[fromSec].title || '(sans titre)';
          const ok = await confirmWarning('Déplacer la partie vers un autre processus ?',
            `Vous allez déplacer « ${secTitle} » de « ${PROCESSES[fromProc].name} » vers « ${PROCESSES[toProc].name} ». Continuer ?`,
            'Oui, déplacer');
          if (!ok) return;
        }
        const [moved]=PROCESSES[fromProc].sections.splice(fromSec,1);
        PROCESSES[toProc].sections.splice(0,0,moved);
        save(); renderAll(); selectProcess(toProc); selectSection(0); toast('Partie déplacée');
      }
    });

    list.appendChild(item);
  });
  });
}

function renderSections(){
  preservePanelScroll(() => {
  const list = $('#sectionList'); list.innerHTML = '';
  const sections = S();
  sections.forEach((sec,i)=>{
    const item = el('div','section-item'); item.draggable=true; item.dataset.index=i;

    const drag = el('div','drag','⋮⋮'); drag.title='Glisser pour réorganiser';
    const title = el('div','title', sec.title || '(sans titre)');
    const pill = el('span','pill', `${(sec.fields||[]).length} item(s)`);
    const right = el('div','right');
    const bUp=el('button','btn','⬆️'); bUp.dataset.act='up';
    const bDown=el('button','btn','⬇️'); bDown.dataset.act='down';
    const bEdit=el('button','btn','Éditer'); bEdit.dataset.act='edit';
    const bDel=el('button','btn danger','Supprimer'); bDel.dataset.act='del';
    const bDup=el('button','btn','Dupliquer'); bDup.dataset.act='dup';
    right.append(bDup, bUp, bDown, bEdit, bDel);
    item.append(drag,title,pill,right);

    item.addEventListener('click',(e)=>{
      const act=e.target.closest('button')?.dataset?.act || 'edit';
      if (act==='edit') selectSection(i);
      else if (act==='dup'){             // ← AJOUT
        duplicateSection(currentProcess, i);
      }
      else if (act==='del'){ if(confirm('Supprimer cette partie ?')){ sections.splice(i,1); selectSection(-1); save(); renderAll(); } }
      else if (act==='up'){ if(i>0){ const [m]=sections.splice(i,1); sections.splice(i-1,0,m); save(); renderAll(); selectSection(i-1); } }
      else if (act==='down'){ if(i<sections.length-1){ const [m]=sections.splice(i,1); sections.splice(i+1,0,m); save(); renderAll(); selectSection(i+1); } }
    });

    item.addEventListener('dragstart',(e)=>{
      item.classList.add('dragging');
      e.dataTransfer.setData('text/plain', i);
      e.dataTransfer.setData(DND_MIME, JSON.stringify({kind:'section', proc: currentProcess, sec:i}));
      e.dataTransfer.effectAllowed='move';
    });
    item.addEventListener('dragend',()=> item.classList.remove('dragging'));
    item.addEventListener('dragover', (e)=>{ if (hasType(e.dataTransfer,'text/plain')){ e.preventDefault(); item.classList.add('drop-target'); } });
    item.addEventListener('dragleave', ()=> item.classList.remove('drop-target'));
    item.addEventListener('drop', (e)=>{
      if (!hasType(e.dataTransfer,'text/plain')) return;
      e.preventDefault();
      const from=+e.dataTransfer.getData('text/plain'); const to=i;
      if (!Number.isInteger(from) || from===to) return;
      const [m]=sections.splice(from,1); sections.splice(to,0,m);
      save(); renderAll(); selectSection(to);
    });

    list.appendChild(item);
  });
  });
}

/* --- Sélection / entrée --- */
function selectProcess(i){
  currentProcess=i; currentSection=-1; editingFieldIndex=-1; editingGroupIndex=-1;
  renderProcesses(); renderSections();
  const pe = $('#processEditor'), ea = $('#editorArea');
  $('#editorTitle').textContent='Aucune partie sélectionnée';
  ea.classList.add('hidden');
  if (pe){
    pe.classList.remove('hidden');
    const input=$('#procName'); input.value=P()?.name || '';
    input.oninput = (e)=>{ if(P()){ P().name=e.target.value; save(); renderProcesses(); renderPreview(); } };
  }
  // si la 1ère section existe, la sélectionner pour que la droite reflète le nouveau template
  if (S().length) { selectSection(0); } else { renderPreview(); }
}

function selectSection(i){
  currentSection=i; editingFieldIndex=-1; editingGroupIndex=-1;
  const title=$('#editorTitle'); const area=$('#editorArea'); const pe=$('#processEditor');
  if (pe) pe.classList.add('hidden');
  if (i<0){ title.textContent='Aucune partie sélectionnée'; area.classList.add('hidden'); renderFields([]); return; }
  title.textContent='Édition de la partie'; area.classList.remove('hidden');
  $('#secTitle').value = S()[i].title || '';
  renderFields(S()[i].fields || []);
  bindSectionInputs();
  bindAddButtons();
  renderPreview();

  // synchroniser immédiatement l’éditeur
  syncEditorToState();
}

function bindSectionInputs(){
  $('#secTitle').oninput = (e)=>{
    if (currentSection<0) return;
    S()[currentSection].title = e.target.value;
    save(); renderSections(); renderPreview();
  };
}
function refreshFieldUI(){ if (currentSection<0) return; renderFields(S()[currentSection].fields || []); }

/* --- Primitives d’insertion / retrait --- */
function getProcess(idx){ return PROCESSES[idx] || null; }
function getSection(procIdx, secIdx){ const p=getProcess(procIdx); return (p && p.sections && p.sections[secIdx]) || null; }

function takeItemFrom(payload){
  const {kind, from, proc, sec, gi, fi} = payload || {};
  const section = getSection(proc, sec); if (!section) return null;

  if (kind === 'field'){
    if (from === 'group'){
      const g = section.fields?.[gi]; if (!g || !isGroup(g)) return null;
      const arr = g.fields || []; const [m] = arr.splice(fi,1); return isField(m)?m:null;
    }else{
      const arr = section.fields || []; const [m]=arr.splice(fi,1); return isField(m)?m:null;
    }
  }
  if (kind === 'group' && from === 'root'){
    const arr = section.fields || []; const [m]=arr.splice(gi,1); return isGroup(m)?m:null;
  }
  return null;
}
function insertFieldAtRoot(procIdx, secIdx, field, beforeIdx=null){
  const sec = getSection(procIdx, secIdx); if (!sec) return;
  const arr = sec.fields || (sec.fields=[]);
  const at = (beforeIdx==null || beforeIdx<0 || beforeIdx>arr.length) ? arr.length : beforeIdx;
  arr.splice(at,0,field);
}
function insertGroupAtRoot(procIdx, secIdx, group, beforeIdx=null){
  const sec = getSection(procIdx, secIdx); if (!sec) return;
  const arr = sec.fields || (sec.fields=[]);
  const at = (beforeIdx==null || beforeIdx<0 || beforeIdx>arr.length) ? arr.length : beforeIdx;
  arr.splice(at,0,group);
}
function insertFieldInGroupByUid(gid, field, beforeIdx=null){
  const { group } = findGroupByUid(gid); if (!group) return;
  const arr = group.fields || (group.fields=[]);
  const at = (beforeIdx==null || beforeIdx<0 || beforeIdx>arr.length) ? arr.length : beforeIdx;
  arr.splice(at,0,field);
}
function findGroupByUid(uid){
  const arr = S()[currentSection]?.fields || [];
  const idx = arr.findIndex(g => isGroup(g) && g.__uid === uid);
  return { index: idx, group: arr[idx] };
}

/* --- Rendu Fields & Groupes --- */
let _dropBusy=false; let _justDroppedAt=0;
function beginDrop(e){ if (_dropBusy) return false; _dropBusy=true; e?.preventDefault?.(); e?.stopPropagation?.(); e?.stopImmediatePropagation?.(); return true; }
function endDrop(){ requestAnimationFrame(()=>{ save(); renderAll(); selectSection(currentSection); _dropBusy=false; }); }
function markDrop(){ _justDroppedAt = performance.now(); }
function isRecentDrop(){ return performance.now() - _justDroppedAt < 150; }

// Mémorise/restaure scroll + focus/caret dans le panneau droit
function preservePanelScroll(run){
  const panel = document.querySelector('.main-panel');
  const st = panel ? panel.scrollTop  : 0;
  const sl = panel ? panel.scrollLeft : 0;

  // focus/caret courant (utile quand on tape dans un input/textarea)
  const ae = document.activeElement;
  const hasSel = ae && (ae.tagName === 'INPUT' || ae.tagName === 'TEXTAREA');
  const ss = hasSel ? ae.selectionStart : null;
  const se = hasSel ? ae.selectionEnd   : null;

  run(); // <-- on effectue le rendu qui casse le scroll

  // on restaure
  if (panel){
    panel.scrollTop  = st;
    panel.scrollLeft = sl;
  }
  if (ae && document.contains(ae)) {
    // on refocus et on remet le caret au même endroit si possible
    try {
      ae.focus();
      if (hasSel && ss != null && se != null) ae.setSelectionRange(ss, se);
    } catch (_) {}
  }
}

function renderFields(items){
  preservePanelScroll(() => {
  const box = $('#fieldList'); box.innerHTML = '';

  if (!box._dndBound){
    box.addEventListener('dragover', (e)=>{
      if (!hasType(e.dataTransfer, DND_MIME)) return;
      e.preventDefault(); e.stopPropagation();
      if (e.target.closest('.group-fields')) return;
      box.classList.add('drop-target');
    });
    box.addEventListener('dragleave', (e)=>{
      e.stopPropagation();
      if (!e.currentTarget.contains(e.relatedTarget)) box.classList.remove('drop-target');
    });
    box.addEventListener('drop', (e)=>{
      if (!beginDrop(e)) return;
      box.classList.remove('drop-target');

      const overItem = e.target.closest('.field-item, .group-item');
      let beforeIdx = null;
      if (overItem && !overItem.closest('.group-fields')) beforeIdx = +overItem.dataset.index;

      const raw = e.dataTransfer.getData(DND_MIME); if (!raw) { endDrop(); return; }
      const payload = JSON.parse(raw);

      if (beforeIdx!=null && payload.from==='root' &&
          payload.proc===currentProcess && payload.sec===currentSection){
        const isGrp = payload.kind==='group';
        const srcIdx = isGrp ? payload.gi : payload.fi;
        if (srcIdx < beforeIdx) beforeIdx -= 1;
      }
      const moved = takeItemFrom(payload); if (!moved) { endDrop(); return; }
      if (isGroup(moved)) insertGroupAtRoot(currentProcess,currentSection,moved,beforeIdx);
      else insertFieldAtRoot(currentProcess,currentSection,moved,beforeIdx);

      e.dataTransfer.dropEffect='move';
      markDrop(); endDrop();
    });
    box._dndBound = true;
  }

  (items||[]).forEach((it, idx)=>{
    if (isGroup(it)){
      const g = el('div','group-item'); g.dataset.index=idx; g.dataset.gid=it.__uid; g.draggable=true;

      const head = el('div','group-head');
      const sel  = document.createElement('input'); sel.type='checkbox'; sel.className='select-box'; sel.dataset.kind='group'; sel.dataset.index=idx; sel.title='Sélectionner';
      const ttl  = el('div','group-title', it.label || it.name || '(groupe)');
      const meta = el('div','group-meta', `required: ${!!it.required} • repeatable: ${!!it.repeatable}`); meta.classList.add('pill');

      const right = el('div','right');
      const bUp=el('button','btn','⬆️'); bUp.dataset.act='up';
      const bDown=el('button','btn','⬇️'); bDown.dataset.act='down';
      const bEdit=el('button','btn','Éditer'); bEdit.dataset.act='edit';
      const bDel=el('button','btn danger','Supprimer'); bDel.dataset.act='del';
      right.append(bUp,bDown,bEdit,bDel);

      head.append(sel, ttl, meta, right);
      const inner = el('div','group-fields');

      // Drag du groupe
      g.addEventListener('dragstart',(e)=>{
        if (e.target.closest('.field-item')) return;
        g.classList.add('dragging');
        e.dataTransfer.effectAllowed='move';
        e.dataTransfer.setData(DND_MIME, JSON.stringify({kind:'group',from:'root',proc:currentProcess,sec:currentSection,gi:idx,gid:it.__uid}));
      });
      g.addEventListener('dragend',()=> g.classList.remove('dragging'));
      g.addEventListener('dragover',(e)=>{ if (hasType(e.dataTransfer,DND_MIME)){ e.preventDefault(); e.stopPropagation(); g.classList.add('drop-before'); }});
      g.addEventListener('dragleave',()=> g.classList.remove('drop-before'));
      g.addEventListener('drop',(e)=>{
        if (!beginDrop(e)) return;
        g.classList.remove('drop-before');
        const payload = JSON.parse(e.dataTransfer.getData(DND_MIME) || '{}');
        const moved = takeItemFrom(payload); if (!moved){ endDrop(); return; }
        let destIndex = idx;
        if (payload.kind==='group' && payload.from==='root' &&
            payload.proc===currentProcess && payload.sec===currentSection && payload.gi < destIndex) destIndex -= 1;
        if (isGroup(moved)) insertGroupAtRoot(currentProcess,currentSection,moved,destIndex);
        else insertFieldAtRoot(currentProcess,currentSection,moved,destIndex);
        e.dataTransfer.dropEffect='move'; markDrop(); endDrop();
      });

      // Conteneur du groupe
      inner.addEventListener('dragover',(e)=>{ if (hasType(e.dataTransfer,DND_MIME)){ e.preventDefault(); e.stopPropagation(); inner.classList.add('drop-target'); }});
      inner.addEventListener('dragleave',(e)=>{ e.stopPropagation(); if (!inner.contains(e.relatedTarget)) inner.classList.remove('drop-target'); });
      inner.addEventListener('drop',(e)=>{
        if (!beginDrop(e)) return;
        inner.classList.remove('drop-target');
        const payload = JSON.parse(e.dataTransfer.getData(DND_MIME) || '{}');
        if (payload.kind !== 'field'){ endDrop(); return; }
        const moved = takeItemFrom(payload); if (!moved || !isField(moved)) { endDrop(); return; }
        insertFieldInGroupByUid(g.dataset.gid, moved, null);
        e.dataTransfer.dropEffect='move'; markDrop(); endDrop();
      });

      // Champs DANS le groupe
      (it.fields||[]).forEach((f,j)=>{
        const item = el('div','field-item'); item.draggable=true; item.dataset.index=`${idx}:${j}`;
        const drag = el('div','drag','⋮'); drag.title='Glisser pour réorganiser/déplacer';
        const cb = document.createElement('input'); cb.type='checkbox'; cb.className='select-box'; cb.dataset.kind='field-in-group'; cb.dataset.index=`${idx}:${j}`; cb.title='Sélectionner';
        const meta = el('div','meta');
        const title = el('div',null);
        const strong = el('strong',null, f.label || f.name || '(sans nom)');
        const muted = el('span','muted', ` (${f.type})`);
        title.append(strong, muted);
        if (isOptType(f.type)){
          const opts = el('span','muted', ` [${(f.options||[]).join(', ')}]`); title.append(' ', opts);
        }
        if (f.tips && (f.tips.text||'').trim()){
          const badge = el('span','pill','Astuce'); title.append(' ', badge);
        }
        const sub = el('div','muted', `name: ${f.name || '—'} • required: ${!!f.required} • repeatable: ${!!f.repeatable}`);
        meta.append(title, sub);

        const right = el('div','right');
        const bUp=el('button','btn','⬆️'); bUp.dataset.act='up';
        const bDown=el('button','btn','⬇️'); bDown.dataset.act='down';
        const bEdit=el('button','btn','Éditer'); bEdit.dataset.act='edit';
        const bDel=el('button','btn danger','Supprimer'); bDel.dataset.act='del';
        right.append(bUp,bDown,bEdit,bDel);

        item.append(drag, cb, meta, right);

        // DnD d'un champ dans un groupe
        item.addEventListener('dragstart',(e)=>{
          item.classList.add('dragging');
          e.dataTransfer.effectAllowed='move';
          e.dataTransfer.setData(DND_MIME, JSON.stringify({kind:'field',from:'group',proc:currentProcess,sec:currentSection,gi:idx,fi:j,gid:it.__uid}));
        });
        item.addEventListener('dragend',()=> item.classList.remove('dragging'));
        item.addEventListener('dragover',(e)=>{ if (hasType(e.dataTransfer,DND_MIME)){ e.preventDefault(); e.stopPropagation(); item.classList.add('drop-before'); }});
        item.addEventListener('dragleave',()=> item.classList.remove('drop-before'));
        item.addEventListener('drop',(e)=>{
          if (!beginDrop(e)) return;
          item.classList.remove('drop-before');
          const payload = JSON.parse(e.dataTransfer.getData(DND_MIME) || '{}');
          if (payload.kind !== 'field'){ endDrop(); return; }
          let dest = j;
          if (payload.from==='group' && payload.gid===it.__uid && payload.fi < dest) dest -= 1;
          const moved = takeItemFrom(payload); if (!moved || !isField(moved)){ endDrop(); return; }
          insertFieldInGroupByUid(it.__uid, moved, dest);
          e.dataTransfer.dropEffect='move'; markDrop(); endDrop();
        });

        // CLIC d'édition sur un champ DANS le groupe
        item.addEventListener('click', (e) => {
          e.stopPropagation();
          if (isRecentDrop()) return;

          const btn = e.target.closest('button[data-act]');
          if (!btn) return;                // ← ne rien faire si on n’a pas cliqué
          const act = btn.dataset.act;

          const sec = S()[currentSection];
          if (!sec) return;
          const grp = sec.fields?.[idx];
          if (!grp || !isGroup(grp)) return;
          const gArr = grp.fields || (grp.fields = []);

          if (act === 'edit') {
            editingGroupIndex = idx;
            editingFieldIndex = j;
            openFieldEditor(gArr[j]);
            highlightEditing();
            scrollEditingIntoView();
            renderPreview();
          } else if (act === 'del') {
            if (confirm('Supprimer ce champ ?')) {
              gArr.splice(j, 1);
              editingFieldIndex = -1;
              save(); renderAll(); selectSection(currentSection); toast('Champ supprimé');
            }
          } else if (act === 'up') {
            if (j > 0) {
              const [m] = gArr.splice(j, 1);
              gArr.splice(j - 1, 0, m);
              editingFieldIndex = j - 1;
              save(); renderAll(); selectSection(currentSection);
            }
          } else if (act === 'down') {
            if (j < gArr.length - 1) {
              const [m] = gArr.splice(j, 1);
              gArr.splice(j + 1, 0, m);
              editingFieldIndex = j + 1;
              save(); renderAll(); selectSection(currentSection);
            }
          }
        });

        inner.appendChild(item);
      });

      g.append(head, inner);

      // CLICS sur l'en-tête du groupe uniquement
      g.addEventListener('click', (e) => {
        if (isRecentDrop()) return;
        if (e.target.closest('.group-fields')) return; // ignorer clics dans les items
        if (!e.target.closest('.group-head')) return;  // ne réagir qu'à l'en-tête

        const act = e.target.closest('button')?.dataset?.act;
        if (!act) return;

        const arr = S()[currentSection].fields;
        if (act === 'edit') {
          editingGroupIndex = idx; editingFieldIndex = -1;
          $('#groupEditor')?.classList.remove('hidden');
          $('#editorArea')?.classList.remove('hidden');
          $('#grpName').value = it.name || '';
          $('#grpLabel').value = it.label || '';
          $('#grpRequired').value = it.required ? 'true' : 'false';
          $('#grpRepeatable').value = it.repeatable ? 'true' : 'false';
          highlightEditing();
          scrollEditingIntoView();
        } else if (act === 'del') {
          if (confirm('Supprimer le groupe ?')) {
            arr.splice(idx, 1); editingGroupIndex = -1;
            save(); renderAll(); selectSection(currentSection); toast('Groupe supprimé');
          }
        } else if (act === 'up') {
          if (idx > 0) { const [m] = arr.splice(idx, 1); arr.splice(idx - 1, 0, m); save(); renderAll(); selectSection(currentSection); }
        } else if (act === 'down') {
          if (idx < arr.length - 1) { const [m] = arr.splice(idx, 1); arr.splice(idx + 1, 0, m); save(); renderAll(); selectSection(currentSection); }
        }
      });

      box.appendChild(g);

    } else {
      // ====== CHAMP RACINE ======
      const f = it;
      const item = el('div','field-item'); item.draggable=true; item.dataset.index=idx;

      const drag = el('div','drag','⋮'); drag.title='Glisser pour réorganiser/déplacer';
      const cb = document.createElement('input'); cb.type='checkbox'; cb.className='select-box'; cb.dataset.kind='field-root'; cb.dataset.index=idx; cb.title='Sélectionner';

      const meta = el('div','meta');
      const title = el('div',null);
      const strong = el('strong',null, f.label || f.name || '(sans nom)');
      const muted = el('span','muted', ` (${f.type})`);
      title.append(strong, muted);
      if (isOptType(f.type)){
        const opts = el('span','muted', ` [${(f.options||[]).join(', ')}]`); title.append(' ', opts);
      }
      if (f.tips && (f.tips.text||'').trim()){
        const badge = el('span','pill','Astuce'); title.append(' ', badge);
      }
      const sub = el('div','muted', `name: ${f.name || '—'} • required: ${!!f.required} • repeatable: ${!!f.repeatable}`);
      meta.append(title, sub);

      const right = el('div','right');
      const bUp=el('button','btn','⬆️'); bUp.dataset.act='up';
      const bDown=el('button','btn','⬇️'); bDown.dataset.act='down';
      const bEdit=el('button','btn','Éditer'); bEdit.dataset.act='edit';
      const bDel=el('button','btn danger','Supprimer'); bDel.dataset.act='del';
      right.append(bUp,bDown,bEdit,bDel);

      item.append(drag, cb, meta, right);

      // DnD champ racine
      item.addEventListener('dragstart',(e)=>{
        e.stopPropagation();
        item.classList.add('dragging');
        e.dataTransfer.effectAllowed='move';
        e.dataTransfer.setData(DND_MIME, JSON.stringify({kind:'field',from:'root',proc:currentProcess,sec:currentSection,fi:+item.dataset.index}));
      });
      item.addEventListener('dragend', (e) => {
        e.stopPropagation();
        item.classList.remove('dragging');
      });
      item.addEventListener('dragover', (e) => {
        e.stopPropagation();
        if (hasType(e.dataTransfer, DND_MIME)) {
          e.preventDefault();
          item.classList.add('drop-before');
        }
      });
      item.addEventListener('dragleave', (e) => {
        e.stopPropagation();
        item.classList.remove('drop-before');
      });
      item.addEventListener('drop',(e)=>{
        if (!beginDrop(e)) return;
        e.stopPropagation();
        item.classList.remove('drop-before');
        const payload = JSON.parse(e.dataTransfer.getData(DND_MIME) || '{}');

        let dest = +item.dataset.index;
        if (payload.from==='root' && payload.proc===currentProcess && payload.sec===currentSection){
          const srcIdx = (payload.kind==='group') ? payload.gi : payload.fi;
          if (srcIdx < dest) dest -= 1;
        }
        const moved = takeItemFrom(payload); if (!moved){ endDrop(); return; }
        if (isGroup(moved)) insertGroupAtRoot(currentProcess,currentSection,moved,dest);
        else insertFieldAtRoot(currentProcess,currentSection,moved,dest);

        e.dataTransfer.dropEffect='move'; markDrop(); endDrop();
      });

      // CLIC d'édition champ RACINE
      item.addEventListener('click',(e)=>{
        if (isRecentDrop()) return;
        const btn = e.target.closest('button[data-act]');
        if (!btn) return;                // ← ne rien faire si on n’a pas cliqué
        const act = btn.dataset.act;
        const arr = S()[currentSection].fields;

        if (act==='edit'){
          editingGroupIndex = -1;
          editingFieldIndex = +item.dataset.index;
          openFieldEditor(arr[editingFieldIndex]);
          highlightEditing();
          scrollEditingIntoView();
          renderPreview();
        } else if (act==='del'){
          if (confirm('Supprimer ce champ ?')){
            const i = +item.dataset.index;
            arr.splice(i,1);
            editingFieldIndex = -1;
            save(); renderAll(); selectSection(currentSection); toast('Champ supprimé');
          }
        } else if (act==='up'){
          const i = +item.dataset.index;
          if (i>0){ const [m]=arr.splice(i,1); arr.splice(i-1,0,m); save(); renderAll(); selectSection(currentSection); }
        } else if (act==='down'){
          const i = +item.dataset.index;
          if (i<arr.length-1){ const [m]=arr.splice(i,1); arr.splice(i+1,0,m); save(); renderAll(); selectSection(currentSection); }
        }
      });

      box.appendChild(item);
    }
  });
  });
  highlightEditing();
}

function openFieldEditor(f){
  const area=$('#editorArea'); area?.classList.remove('hidden');
  $('#groupEditor')?.classList.add('hidden');
  $('#fldName').value = f.label || '';
  $('#fldLabel').value = f.label || '';
  $('#fldType').value = f.type || 'text';
  $('#fldRequired').value = f.required ? 'true' : 'false';
  $('#fldRepeatable').value = f.repeatable ? 'true' : 'false';
  $('#fldOptions').value = (Array.isArray(f.options)? f.options : []).join(', ');
  $('#fldTipsIcon').value = (f.tips?.icon)||'';
  $('#fldTips').value = (f.tips?.text)||'';
  updateTipsPreview(f);
  updateOptionsVisibility();
  $('#fldName').focus();
}

function clearFieldEditorUI(){
  $('#editorArea')?.classList.add('hidden');
  $('#groupEditor')?.classList.add('hidden');
  $('#editorTitle').textContent = (currentSection>=0) ? 'Édition de la partie' : 'Aucune partie sélectionnée';
  // Nettoie les inputs pour éviter l’effet “valeurs fantômes”
  ['#fldName','#fldLabel','#fldOptions','#fldTipsIcon','#fldTips'].forEach(s=>{ const el=$(s); if(el) el.value=''; });
}

function highlightEditing(){
  // Retire les marquages précédents
  $$('.field-item.editing, .group-item.editing').forEach(n=>n.classList.remove('editing'));
  if (currentSection<0) return;

  if (editingGroupIndex>=0){
    const g = $(`#fieldList .group-item[data-index="${editingGroupIndex}"]`);
    if (g) g.classList.add('editing');

    if (editingFieldIndex>=0){
      const f = $(`#fieldList .group-item[data-index="${editingGroupIndex}"] .field-item[data-index="${editingGroupIndex}:${editingFieldIndex}"]`);
      if (f) f.classList.add('editing');
    }
  } else if (editingFieldIndex>=0){
    const f = $(`#fieldList .field-item[data-index="${editingFieldIndex}"]`);
    if (f) f.classList.add('editing');
  }
}

function scrollEditingIntoView(){
  // Scroll “doux” vers l’élément en édition si présent
  const target =
    (editingGroupIndex>=0 && editingFieldIndex>=0) ? $(`#fieldList .group-item[data-index="${editingGroupIndex}"] .field-item[data-index="${editingGroupIndex}:${editingFieldIndex}"]`) :
    (editingGroupIndex>=0) ? $(`#fieldList .group-item[data-index="${editingGroupIndex}"]`) :
    (editingFieldIndex>=0) ? $(`#fieldList .field-item[data-index="${editingFieldIndex}"]`) : null;

  if (target) target.scrollIntoView({behavior:'instant', block:'center'});
}

function syncEditorToState(){
  // Si pas de section sélectionnée → UI neutre
  if (currentSection<0){ clearFieldEditorUI(); renderPreview(); return; }

  const sec = S()[currentSection];
  const root = sec?.fields || [];

  // Cas 1: un champ “racine” est en cours d’édition
  if (editingGroupIndex<0 && editingFieldIndex>=0 && root[editingFieldIndex] && root[editingFieldIndex].__kind==='field'){
    $('#editorArea')?.classList.remove('hidden');
    $('#groupEditor')?.classList.add('hidden');
    openFieldEditor(root[editingFieldIndex]);
    highlightEditing(); scrollEditingIntoView(); return;
  }

  // Cas 2: un groupe est en édition
  if (editingGroupIndex>=0 && root[editingGroupIndex] && root[editingGroupIndex].__kind==='group'){
    const g = root[editingGroupIndex];

    // a) édition du groupe lui-même
    if (editingFieldIndex<0){
      $('#groupEditor')?.classList.remove('hidden');
      $('#editorArea')?.classList.remove('hidden');
      $('#grpName').value = g.name || '';
      $('#grpLabel').value = g.label || '';
      $('#grpRequired').value = g.required ? 'true' : 'false';
      $('#grpRepeatable').value = g.repeatable ? 'true' : 'false';
      highlightEditing(); scrollEditingIntoView(); return;
    }

    // b) édition d’un champ à l’intérieur du groupe
    const f = g.fields?.[editingFieldIndex];
    if (f){
      $('#groupEditor')?.classList.add('hidden');
      $('#editorArea')?.classList.remove('hidden');
      openFieldEditor(f);
      highlightEditing(); scrollEditingIntoView(); return;
    }
  }

  // Rien de ciblé → par défaut on ouvre la section (et éventuellement premier champ s’il existe)
  if (root.length){
    // Si le 1er item est un champ → l’ouvrir ; si c’est un groupe → ouvrir le groupe
    if (root[0].__kind==='field'){ editingGroupIndex=-1; editingFieldIndex=0; openFieldEditor(root[0]); }
    else if (root[0].__kind==='group'){ editingGroupIndex=0; editingFieldIndex=-1;
      $('#groupEditor')?.classList.remove('hidden');
      $('#editorArea')?.classList.remove('hidden');
      $('#grpName').value = root[0].name || '';
      $('#grpLabel').value = root[0].label || '';
      $('#grpRequired').value = root[0].required ? 'true' : 'false';
      $('#grpRepeatable').value = root[0].repeatable ? 'true' : 'false';
    } else {
      clearFieldEditorUI();
    }
  } else {
    clearFieldEditorUI();
  }
  highlightEditing(); scrollEditingIntoView();
}
  
function renderAll(){
  preservePanelScroll(() => {
    renderProcesses();
    renderSections();
    renderPreview();
  });
}

/* --- Aperçu JSON --- */
function cleanItem(it){
  if (isGroup(it)){
    const g = { group:{ name:(it.name||'').trim(), ...(it.label?{label:String(it.label).trim()}:{}), ...(it.required?{required:true}:{}) , ...(it.repeatable?{repeatable:true}:{}) } };
    g.fields = (it.fields||[]).filter(isField).map(f=>{
      const out={ name:(f.name||'').trim(), type:f.type||'text' };
      if (f.label) out.label=String(f.label).trim();
      if (f.repeatable) out.repeatable=true;
      if (f.required) out.required=true;
      if (isOptType(f.type)) out.options=(f.options||[]).filter(x=>String(x).trim()!=='').map(String);
      if (f.tips && (String(f.tips.icon||'').trim() || String(f.tips.text||'').trim())){
        out.tips = { ...(f.tips.icon?{icon:String(f.tips.icon)}:{}), ...(f.tips.text?{text:String(f.tips.text)}:{}) };
      }
      return out;
    });
    return g;
  }
  const out={ name:(it.name||'').trim(), type:it.type||'text' };
  if (it.label) out.label=String(it.label).trim();
  if (it.repeatable) out.repeatable=true;
  if (it.required) out.required=true;
  if (isOptType(it.type)) out.options=(it.options||[]).filter(x=>String(x).trim()!=='').map(String);
  if (it.tips && (String(it.tips.icon||'').trim() || String(it.tips.text||'').trim())){
    out.tips = { ...(it.tips.icon?{icon:String(it.tips.icon)}:{}), ...(it.tips.text?{text:String(it.tips.text)}:{}) };
  }
  return out;
}
function getCleanModel(){
  return PROCESSES
    .filter(p=>p.enabled!==false)
    .map(p=>({ name:(p.name||'').trim(), sections:(p.sections||[]).map(sec=>({ title:(sec.title||'').trim(), fields:(sec.fields||[]).map(cleanItem) })) }));
}
function renderPreview(){
  const clean=getCleanModel();
  $('#jsonPreview').textContent = JSON.stringify(clean, null, 2);
  const procs=clean.length;
  const secs = clean.reduce((a,p)=> a+(p.sections?.length||0),0);
  const items=clean.reduce((a,p)=> a+(p.sections||[]).reduce((b,s)=> b+(s.fields?.length||0),0),0);
  $('#countProcesses').textContent = procs + ' processus';
  $('#countSections').textContent  = secs  + ' partie' + (secs>1?'s':'');
  $('#countFields').textContent    = items + ' item' + (items>1?'s':'');
}

/* --- Éditeurs & actions --- */
function bindAddButtons(){ $('#btnAddFieldTop').onclick = addNewField; $('#btnAddFieldSticky').onclick = addNewField; }
function updateOptionsVisibility(){ const t = $('#fldType').value; $('#rowOptions').style.display = isOptType(t) ? '' : 'none'; }

function addNewField(){
  if (currentSection<0) createSection();
  const sec = S()[currentSection];
  const to = (editingGroupIndex>=0 && isGroup(sec.fields[editingGroupIndex])) ? sec.fields[editingGroupIndex].fields : (sec.fields || (sec.fields=[]));
  const f = makeField();
  f.name = uniqueName(tinyName('champ'));
  to.push(f);
  editingFieldIndex = to.length - 1;
  $('#fldName').value=''; $('#fldLabel').value=''; $('#fldType').value='text';
  $('#fldRequired').value='false'; $('#fldRepeatable').value='false'; $('#fldOptions').value='';
  $('#fldTipsIcon').value=''; $('#fldTips').value=''; updateTipsPreview(f);
  updateOptionsVisibility(); renderFields(sec.fields); $('#fldName').focus();
  save(); renderPreview(); toast('Champ ajouté');
}

function groupSelected(){
  if (currentSection<0) return;
  const sec = S()[currentSection]; const arr = sec.fields || (sec.fields=[]);
  const selected = $$('.select-box[data-kind="field-root"]:checked').map(cb => +cb.dataset.index).sort((a,b)=>a-b);
  if (selected.length < 1){ toast('Sélectionne au moins un champ racine'); return; }
  const group = makeGroup(); group.label='Nouveau groupe'; group.name = uniqueName(tinyName(group.label||'groupe'));
  const moved=[];
  for (let i=selected.length-1;i>=0;i--){ const idx=selected[i]; const it=arr[idx]; if (isField(it)){ moved.unshift(it); arr.splice(idx,1); } }
  if (!moved.length){ toast('Aucun champ racine sélectionné'); return; }
  group.fields=moved; arr.push(group);
  save(); renderAll(); selectSection(currentSection); toast('Champs regroupés');
}

/* Import / validation */
function validateTemplate(tpl){
  if (!Array.isArray(tpl)) return { valid:false, reason:'Racine non tableau (processus[])' };
  for (let i=0;i<tpl.length;i++){
    const p = tpl[i] || {};
    if (typeof p !== 'object') return { valid:false, reason:`processus[${i}] non objet` };
    if (!('name' in p)) return { valid:false, reason:`processus[${i}] sans "name"` };
    if (!Array.isArray(p.sections)) return { valid:false, reason:`processus[${i}].sections doit être un tableau` };
    for (let s=0;s<p.sections.length;s++){
      const sec=p.sections[s]||{};
      if (typeof sec!=='object') return { valid:false, reason:`sections[${s}] non objet` };
      if (!('title' in sec)) return { valid:false, reason:`sections[${s}] sans "title"` };
      if (sec.fields && !Array.isArray(sec.fields)) return { valid:false, reason:`sections[${s}].fields doit être un tableau` };
      const fields=sec.fields||[];
      for (let j=0;j<fields.length;j++){
        const f=fields[j]||{};
        const isGrp=('group' in f)&&typeof f.group==='object'&&Array.isArray(f.fields);
        const isFld=('name' in f)&&('type' in f);
        if (!isGrp && !isFld) return { valid:false, reason:`fields[${j}] doit être un champ (name/type) ou un groupe (group/fields)` };
        if (isFld && (f.type==='radio'||f.type==='select') && f.options && !Array.isArray(f.options))
          return { valid:false, reason:`fields[${j}].options doit être un tableau` };
        if (isGrp){
          for (let k=0;k<f.fields.length;k++){
            const gch=f.fields[k]||{};
            if (!gch.name) return { valid:false, reason:`group.fields[${k}] sans "name"` };
            if (!gch.type) return { valid:false, reason:`group.fields[${k}] sans "type"` };
            if ((gch.type==='radio'||gch.type==='select') && gch.options && !Array.isArray(gch.options))
              return { valid:false, reason:`group.fields[${k}].options doit être un tableau` };
          }
        }
      }
    }
  }
  return { valid:true };
}

/* UML SVG (sans canvas ; pas d’export PNG) */
function safeCssVar(name, fallback){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim() || fallback; }
function generateUmlSVGFor(proc){
  if (!proc) return '';
  const sections = (proc.sections||[]);
  const W = 1200, PAD=24, COLW=W-PAD*2, BOXR=12;
  const BG     = safeCssVar('--bg','#f6f7fb');
  const FG     = safeCssVar('--fg','#111827');
  const PANEL  = safeCssVar('--panel','#ffffff');
  const BORDER = safeCssVar('--card-border','#e5e7eb');
  const ACCENT = safeCssVar('--accent','#2563eb');
  const MUTED  = safeCssVar('--muted','#6b7280');

  const wrapTitle = (t)=> wrapByChars(t, 80);
  const wrapLine  = (t)=> wrapByChars(t, 120);

  const nodes = [{ kind:'start', title:'Start', w:260, h:40 }];
  let nodesSum = 0;
  sections.forEach((sec, si)=>{
    const titleLines = wrapTitle(sec.title || '(section)');
    let innerH = titleLines.length*20 + 8;
    const items=[];
    (sec.fields||[]).forEach(it=>{
      if (isGroup(it)){
        const head = `Groupe: ${it.label || it.name || '(groupe)'}  • req:${!!it.required} • rep:${!!it.repeatable}`;
        items.push({t:head, type:'group-head'});
        (it.fields||[]).forEach(f=>{
          const opts=(isOptType(f.type)&&Array.isArray(f.options)&&f.options.length)?` [${f.options.join(', ')}]`:'';
          const tip =(f.tips&&f.tips.text&&f.tips.text.trim())?' • 💡':'';
          items.push({t:`• ${f.label || f.name || '(champ)'} (${f.type}) • req:${!!f.required} • rep:${!!f.repeatable}${opts}${tip}`, type:'group-item'});
        });
        items.push({t:'',type:'spacer'});
      }else{
        const f=it;
        const opts=(isOptType(f.type)&&Array.isArray(f.options)&&f.options.length)?` [${f.options.join(', ')}]`:'';
        const tip =(f.tips&&f.tips.text&&f.tips.text.trim())?' • 💡':'';
        items.push({t:`• ${f.label || f.name || '(champ)'} (${f.type}) • req:${!!f.required} • rep:${!!f.repeatable}${opts}${tip}`, type:'field'});
      }
    });
    items.forEach(l=>{ const ls=wrapLine(l.t); l._lines=ls; innerH += (ls.length||1)*20 + (l.type==='spacer'?8:0); });
    const h = innerH+32;
    nodes.push({ kind:'section', titleLines, items, w:COLW, h, index:si });
    nodesSum += h + 24;
  });
  nodes.push({ kind:'end', title:'End', w:260, h:40 }); nodesSum += 40 + 24 + 40;

  const procLines = wrapTitle(proc.name || '(processus)');
  const subtitle  = `${sections.length} partie(s) • export: ${new Date().toLocaleString()}`;
  const subLines  = wrapByChars(subtitle, 90);
  const headerH   = procLines.length*20 + 8 + subLines.length*18 + 10;
  const totalH    = PAD + headerH + nodesSum + PAD;

  const esc = s=>String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  const textLines=(x,yTop,lines,{family='Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial',size=14,weight=400,fill=FG,line=20})=>{
    let out='', y=yTop; for(const ln of lines){ out+=`<text x="${x}" y="${y}" font-family="${family}" font-size="${size}px" font-weight="${weight}" fill="${fill}">${esc(ln)}</text>`; y+=line; } return out;
  };
  const rect=(x,y,w,h,r,fill,stroke)=>`<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="${r}" ry="${r}" fill="${fill}" stroke="${stroke}" />`;

  let y=PAD, out=[];
  out.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${totalH}" viewBox="0 0 ${W} ${totalH}">
  <rect x="0" y="0" width="${W}" height="${totalH}" fill="${BG}"/>`);

  out.push(textLines(PAD, y+22, procLines, {size:24,weight:600,fill:FG,line:20})); y += procLines.length*20 + 8;
  out.push(textLines(PAD, y+16, subLines, {size:13,weight:400,fill:MUTED,line:18})); y += subLines.length*18 + 10;

  let prevX = PAD + (COLW/2), prevY = y;
  nodes.forEach((n, idx)=>{
    if (n.kind==='start' || n.kind==='end'){
      const nx = PAD + (COLW - n.w)/2, ny=y;
      out.push(rect(nx, ny, n.w, n.h, 20, ACCENT, ACCENT));
      out.push(`<text x="${nx+n.w/2}" y="${ny+n.h/2+5}" text-anchor="middle" font-family="Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial" font-size="14px" font-weight="700" fill="#fff">${esc(n.title)}</text>`);
      if (idx>0) out.push(`<line x1="${prevX}" y1="${prevY}" x2="${PAD+COLW/2}" y2="${ny}" stroke="${ACCENT}" stroke-width="2" />`);
      y += n.h + 24; prevX = PAD+COLW/2; prevY = ny+n.h; return;
    }
    const nx=PAD, ny=y;
    out.push(rect(nx, ny, n.w, n.h, BOXR, PANEL, BORDER));
    const innerX=nx+16, innerY0=ny+16;
    out.push(textLines(innerX, innerY0+18, n.titleLines, {size:18,weight:700,fill:ACCENT,line:20}));
    let yy = innerY0 + n.titleLines.length*20 + 8;
    n.items.forEach(it=>{
      const color = it.type==='group-item' ? MUTED : FG;
      const lines = it._lines && it._lines.length ? it._lines : [''];
      out.push(textLines(innerX, yy+16, lines, {size:14,weight:400,fill:color,line:20}));
      yy += lines.length*20 + (it.type==='spacer'?8:0);
    });
    out.push(`<line x1="${prevX}" y1="${prevY}" x2="${PAD+COLW/2}" y2="${ny}" stroke="${ACCENT}" stroke-width="2" />`);
    y += n.h + 24; prevX = PAD+COLW/2; prevY = ny+n.h;
  });

  out.push(`</svg>`);
  return out.join('\n');
}
</script>

<!-- =========================
     PARTIE 3/3 — BINDINGS & BOOT
     ========================= -->
<script>
function createSection(){
  const p=P(); if (!p) return;
  p.sections.push(makeSection());
  editingGroupIndex=-1; editingFieldIndex=-1;
  save(); renderAll(); selectSection(p.sections.length-1);
  toast('Partie ajoutée');
}

function bindFieldInputsLive(){
  const map = {
    '#fldName': (el, f)=>{
      const label = el.value || '';
      f.label = label; $('#fldLabel').value = label;
      if (f.nameAuto !== false){ f.name = uniqueName(tinyName(label || 'champ')); }
    },
    '#fldLabel': (el, f)=>{
      const label = el.value || '';
      f.label = label; $('#fldName').value = label;
      if (f.nameAuto !== false){ f.name = uniqueName(tinyName(label || 'champ')); }
    },
    '#fldType': (el, f)=>{ f.type = el.value; if(!isOptType(f.type)) f.options=[]; updateOptionsVisibility(); },
    '#fldRequired': (el, f)=>{ f.required = (el.value==='true'); },
    '#fldRepeatable':(el, f)=>{ f.repeatable = (el.value==='true'); },
    '#fldOptions':   (el, f)=>{ f.options = el.value.split(',').map(s=>s.trim()).filter(Boolean); },
    '#fldTipsIcon':  (el, f)=>{ f.tips = f.tips || {icon:'',text:''}; f.tips.icon = el.value; updateTipsPreview(f); },
    '#fldTips':      (el, f)=>{ f.tips = f.tips || {icon:'',text:''}; f.tips.text = el.value; updateTipsPreview(f); }
  };
  Object.entries(map).forEach(([sel, apply])=>{
    const el = document.querySelector(sel); if (!el) return;
    const evt = (sel==='#fldType' || sel==='#fldRequired' || sel==='#fldRepeatable') ? 'change' : 'input';
    el.addEventListener(evt, ()=>{
      if (currentSection<0) createSection();
      const sec = S()[currentSection];
      let f;
      if (editingGroupIndex>=0 && isGroup(sec.fields?.[editingGroupIndex])){
        const g = sec.fields[editingGroupIndex];
        if (editingFieldIndex < 0){ (g.fields||(g.fields=[])).push(makeField()); editingFieldIndex=g.fields.length-1; }
        f = g.fields[editingFieldIndex];
      } else {
        if (editingFieldIndex < 0){ (sec.fields||(sec.fields=[])).push(makeField()); editingFieldIndex=sec.fields.length-1; }
        f = sec.fields[editingFieldIndex];
      }
      apply(el, f);
      save(); renderPreview(); refreshFieldUI();
    });
  });

  const groupMap = {
    '#grpLabel': (el, g)=>{
      g.label = el.value;
      if (g.nameAuto){
        const base = tinyName(g.label || 'groupe');
        g.name = uniqueName(base);
        $('#grpName').value = g.name;
      }
    },
    '#grpName': (el, g)=>{
      g.nameAuto = false;
      const base = tinyName(el.value || g.label || 'groupe');
      g.name = uniqueName(base);
      el.value = g.name;
    },
    '#grpRequired':  (el, g)=>{ g.required  = (el.value==='true'); },
    '#grpRepeatable':(el, g)=>{ g.repeatable= (el.value==='true'); }
  };
  Object.entries(groupMap).forEach(([sel, apply])=>{
    const el = document.querySelector(sel); if (!el) return;
    const evt = (sel==='#grpRequired' || sel==='#grpRepeatable') ? 'change' : 'input';
    el.addEventListener(evt, ()=>{
      if (currentSection<0 || editingGroupIndex<0) return;
      const g = S()[currentSection].fields?.[editingGroupIndex]; if (!isGroup(g)) return;
      apply(el, g);
      save(); renderPreview(); renderFields(S()[currentSection].fields);
    });
  });

  $('#btnDeleteGroup').addEventListener('click', ()=>{
    if (currentSection<0 || editingGroupIndex<0) return;
    S()[currentSection].fields.splice(editingGroupIndex,1);
    editingGroupIndex=-1;
    save(); renderAll(); selectSection(currentSection);
  });
}

function buildIconPicker(){
  const ICONS = ["💡","ℹ️","📌","📎","✅","⚠️","🚫","📝","🧠","🧩","🔗","📂","📄","📣","🕒","🧪","💬","🧷","🔍","📷","🖇️","📦","🗂️","🧭","📚","🧾","🧯","🎯","🛠️","🧱","🪪","🧷","💾","🧑‍🏫","🏷️","🪄","💭","🚀"];
  const grid = $('#iconGrid'); if (!grid) return; grid.innerHTML='';
  ICONS.forEach(ic=>{
    const b = document.createElement('button'); b.type='button'; b.textContent=ic;
    b.addEventListener('click', ()=>{ const inp=$('#fldTipsIcon'); inp.value=ic; inp.dispatchEvent(new Event('input',{bubbles:true})); grid.classList.add('hidden'); });
    grid.appendChild(b);
  });
  const dl = $('#iconDatalist'); if (dl){ dl.innerHTML = ICONS.map(i=>`<option value="${i}">`).join(''); }
  $('#btnToggleIconPicker')?.addEventListener('click', ()=> grid.classList.toggle('hidden'));
  document.addEventListener('click',(e)=>{ if (!grid.contains(e.target) && e.target !== $('#btnToggleIconPicker')) grid.classList.add('hidden'); });
}

function ensureGroupUids(){
  PROCESSES.forEach(p=> (p.sections||[]).forEach(sec=> (sec.fields||[]).forEach(it=>{ if (isGroup(it) && !it.__uid) it.__uid = genUid(); })));
}

/* ZIP util (zip.js) — export UML uniquement en SVG (pas de PNG, pas de canvas) */
async function makeZipAES(files, password){
  if (!window.zip) throw new Error('zip.js introuvable');
  const writer = new zip.ZipWriter(new zip.BlobWriter('application/zip'), {
    password, encryptionStrength: 3, zipCrypto: false, level: 0
  });
  for (const f of files){
    await writer.add(f.name, new zip.Uint8ArrayReader(f.data), { lastModDate: f.date || new Date() });
  }
  return await writer.close();
}

// (REMPLACE) ZIP chiffré **ZipCrypto** (compatible Explorateur Windows)
async function makeZipForWindows(files, password){
  if (!window.zip) throw new Error('zip.js introuvable');
  const writer = new zip.ZipWriter(new zip.BlobWriter('application/zip'), {
    password,          // ← active le chiffrement
    zipCrypto: true,   // ← **INDISPENSABLE** pour Windows Explorer
    level: 9           // (optionnel) meilleure compression
  });
  for (const f of files){
    await writer.add(
      f.name,
      new zip.Uint8ArrayReader(f.data),
      { lastModDate: f.date || new Date() }
    );
  }
  return await writer.close();
}

// ⚠️ Avertissement sécurité faible (ZipCrypto pour Windows)
async function warnWeakZipCrypto(){
  return await confirmWarning(
    '⚠️ Limitation de sécurité imposée par Microsoft Windows',
    "Ce ZIP sera chiffré en ZipCrypto, un mécanisme ancien, vulnérable et facilement cassable.\n\n" +
    "➡️ **Important : ce choix n’est pas dû à l’application**, mais à une limitation de l’Explorateur Windows, qui refuse d’ouvrir les ZIP protégés avec un chiffrement moderne (AES) et n’accepte que ce vieux standard.\n\n" +
    "Conséquences :\n" +
    "• Considérez que ce ZIP est faiblement protégé, presque comme s’il ne l’était pas.\n" +
    "• Ne stockez pas ce ZIP sur des canaux non sûrs (cloud public, USB partagé, e-mail non sécurisé…)\n" +
    "• Ne le partagez qu’avec des personnes de confiance\n" +
    "En continuant, vous reconnaissez cette faiblesse imposée par Microsoft Windows et acceptez les risques.",
    "J’ai compris, continuer"
  );
}

function strToU8(s){ return new TextEncoder().encode(s); }
function safeName(s){ return String(s||'processus').replace(/[^\p{L}\p{N}\-_.]+/gu,'_'); }

async function exportAllUmlZIP(){
  const procs = PROCESSES.filter(p=>p.enabled!==false);
  if (!procs.length){ alert('Aucun processus activé'); return; }
  
  const okWeak = await warnWeakZipCrypto();
  if (!okWeak) return;
  
  const pwd = await promptPassword('Schéma UML (ZIP protégé)', 'Choisissez un mot de passe pour le ZIP.');
  if (!pwd) return;

  const files = [];
  for (const p of procs){
    const svg = generateUmlSVGFor(p);
    const base = safeName(p.name||'processus');
    // SVG
    const svgU8 = strToU8(svg);
    files.push({ name: `${base}.uml.svg`, data: svgU8, date:new Date() });
    // PNG
    const pngBlob = await svgTextToPngBlob(svg);
    const buf = new Uint8Array(await pngBlob.arrayBuffer());
    files.push({ name: `${base}.uml.png`, data: buf, date:new Date() });
  }

  let zipBlob;
  try{
    zipBlob = await makeZipForWindows(files, pwd);    // << chiffrage ZipCrypto (faible, imposé par Microsoft Windows)
  }catch(e){
    // Fallback (non chiffré) si zip.js indispo
    console.warn('zip.js indisponible, fallback non chiffré', e);
    zipBlob = await makeZip(files);            // << store only (non protégé)
  }
  const zipUrl = URL.createObjectURL(zipBlob);
  const name = `uml_exports_${new Date().toISOString().replace(/[:.]/g,'-')}.zip`;
  const a = document.createElement('a'); a.href = zipUrl; a.download = name; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(zipUrl);
  toast('ZIP UML exporté (protégé) ✅');
}

// --- AJOUT 1 : ZIP non chiffré (fallback) ---
async function makeZip(files){
  if (!window.zip) throw new Error('zip.js introuvable');
  const writer = new zip.ZipWriter(new zip.BlobWriter('application/zip')); // pas de password
  for (const f of files){
    await writer.add(
      f.name,
      new zip.Uint8ArrayReader(f.data),
      { lastModDate: f.date || new Date() }
    );
  }
  return await writer.close();
}

// --- AJOUT 2 : Rasterisation SVG -> PNG via <canvas> ---
async function svgTextToPngBlob(svgText, scale = 2){
  const svgBlob = new Blob([svgText], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(svgBlob);
  try{
    const img = new Image();
    img.decoding = 'async';
    const loaded = new Promise((resolve, reject)=>{
      img.onload = () => resolve();
      img.onerror = reject;
    });
    img.src = url;
    await loaded;

    const w = img.naturalWidth  || img.width;
    const h = img.naturalHeight || img.height;

    const canvas = document.createElement('canvas');
    canvas.width  = Math.ceil(w * scale);
    canvas.height = Math.ceil(h * scale);

    const ctx = canvas.getContext('2d');
    ctx.setTransform(scale, 0, 0, scale, 0, 0);
    ctx.drawImage(img, 0, 0);

    const pngBlob = await new Promise((res)=> canvas.toBlob(res, 'image/png'));
    if (!pngBlob) throw new Error('canvas.toBlob a retourné null');
    return pngBlob;
  } finally {
    URL.revokeObjectURL(url);
  }
}

async function exportProcessAsZip(){
  // 1) Construire le JSON “processes[]” attendu par !nsights
  const processes = getCleanModel();
  if (!Array.isArray(processes) || processes.length === 0){
    alert('Aucun processus activé à exporter.');
    return;
  }

  // 2) Avertissement même que l’export UML (ZipCrypto = faible)
  const okWeak = await warnWeakZipCrypto();
  if (!okWeak) return;

  // 3) Mot de passe du ZIP (le JSON à l’intérieur reste en clair)
  const pwd = await promptPassword(
    'Exporter le processus (ZIP protégé)',
    "Choisissez un mot de passe pour le ZIP.\n\n"+
    "⚠️ Le JSON à l’intérieur du ZIP est en clair (non chiffré).\n"+
    "Ouvrez le ZIP puis importez le fichier JSON dans l’app !nsights."
  );
  if (!pwd) return;

  // 4) Préparer les fichiers à mettre dans le ZIP
  const jsonPretty = JSON.stringify(processes, null, 2);
  const readme = [
    "==================== AVERTISSEMENT ====================",
    "Ce ZIP est protégé par mot de passe via ZipCrypto (faible).",
    "Le JSON à l’intérieur est EN CLAIR (non chiffré).",
    "=======================================================",
    "",
    "Pour importer dans !nsights :",
    "1) Décompressez ce ZIP.",
    "2) Dans !nsights, cliquez sur « 🧩 Choisir processus ».",
    "3) Sélectionnez le fichier « processus.json ».",
    "4) Cliquez sur « Charger le processus ».",
    "",
    "Format exporté : tableau de processus",
    "[{ name, sections:[{ title, fields:[ … ]}] }]",
    ""
  ].join("\n");

  const files = [
    { name: 'processus.json', data: strToU8(jsonPretty), date:new Date() },
    { name: 'README.txt',   data: strToU8(readme),      date:new Date() }
  ];

  // 5) Créer le ZIP protégé par mot de passe (ZipCrypto)
  let zipBlob;
  try{
    zipBlob = await makeZipForWindows(files, pwd); // zipCrypto:true à l’intérieur
  }catch(e){
    console.warn('zip.js indisponible, fallback en ZIP non protégé', e);
    zipBlob = await makeZip(files); // fallback non chiffré si besoin
  }

  // 6) Télécharger le ZIP
  const name = `processus_${new Date().toISOString().replace(/[:.]/g,'-')}.zip`;
  const url = URL.createObjectURL(zipBlob);
  const a = document.createElement('a');
  a.href = url; a.download = name;
  document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(url);

  toast('ZIP processus exporté (protégé) ✅\nOuvrez le ZIP et importez « processus.json » dans !nsights.');
}

/* Bind global */
function bindGlobal(){
  $('#btnNewProcess').addEventListener('click', ()=>{
    PROCESSES.push(makeProcess());
    currentProcess=PROCESSES.length-1; currentSection=-1;
    save(); renderAll(); selectProcess(currentProcess); toast('Processus ajouté');
  });
  $('#fabAdd').addEventListener('click', ()=> $('#btnNewProcess').click());
  $('#btnNewSection').addEventListener('click', createSection);

  $('#btnDeleteSection').addEventListener('click', ()=>{
    if (currentSection<0) return;
    const sections=S();
    if (!confirm('Supprimer cette partie et tous ses items ?')) return;
    sections.splice(currentSection,1);
    save(); renderAll(); selectSection(-1); toast('Partie supprimée');
  });

  $('#btnFieldUp').addEventListener('click', ()=>{
    if (currentSection<0) return;
    const sec=S()[currentSection];
    if (editingGroupIndex>=0 && editingFieldIndex>=0 && isGroup(sec.fields[editingGroupIndex])){
      const arr=sec.fields[editingGroupIndex].fields; const i=editingFieldIndex;
      if (i>0){ const [m]=arr.splice(i,1); arr.splice(i-1,0,m); editingFieldIndex=i-1; save(); renderFields(sec.fields); renderPreview(); }
      return;
    }
    if (editingFieldIndex<0) return;
    const arr=sec.fields; const i=editingFieldIndex;
    if (i>0){ const [m]=arr.splice(i,1); arr.splice(i-1,0,m); editingFieldIndex=i-1; save(); renderFields(arr); renderPreview(); }
  });

  $('#btnFieldDown').addEventListener('click', ()=>{
    if (currentSection<0) return;
    const sec=S()[currentSection];
    if (editingGroupIndex>=0 && editingFieldIndex>=0 && isGroup(sec.fields[editingGroupIndex])){
      const arr=sec.fields[editingGroupIndex].fields; const i=editingFieldIndex;
      if (i<arr.length-1){ const [m]=arr.splice(i,1); arr.splice(i+1,0,m); editingFieldIndex=i+1; save(); renderFields(sec.fields); renderPreview(); }
      return;
    }
    if (editingFieldIndex<0) return;
    const arr=sec.fields; const i=editingFieldIndex;
    if (i<arr.length-1){ const [m]=arr.splice(i,1); arr.splice(i+1,0,m); editingFieldIndex=i+1; save(); renderFields(arr); renderPreview(); }
  });

  // Export JSON -> chiffré AES-GCM
  $('#btnExport').addEventListener('click', async ()=>{
    const pwd = await promptPassword('Exporter JSON (protégé)', "Entrez un mot de passe pour chiffrer l'export.");
    if (!pwd) return;
    const clean=getCleanModel();
    const payload=await aesGcmEncryptFromString(pwd, JSON.stringify(clean,null,2));
    const blob=new Blob([JSON.stringify(payload,null,2)], {type:'application/json'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download='template.processes.enc.json';
    document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove();
    toast('JSON chiffré exporté ✅');
  });

  // Copie en clair
  $('#btnCopy').addEventListener('click', async ()=>{
    const ok = await confirmWarning('Copier le JSON en clair',"Vous allez copier le modèle en clair dans le presse-papiers. Évitez de le coller dans des outils non sûrs.",'Copier quand même');
    if (!ok) return;
    try{
      const clean=getCleanModel();
      await navigator.clipboard.writeText(JSON.stringify(clean,null,2));
      toast('JSON copié (en clair) ✅');
    }catch(e){ alert("Impossible de copier dans le presse-papiers."); }
  });

  // Import JSON (détecte chiffrage)
  $('#fileImport').addEventListener('change', async (e)=>{
    const f=e.target.files?.[0]; if (!f) return;
    try{
      const txt=await f.text(); let json=JSON.parse(txt);
      if (json && json.format==='IF-AESGCM-v1' && json.ct && json.iv && json.salt){
        const pwd = await promptPassword('Importer JSON (protégé)','Saisissez le mot de passe du fichier.');
        if (!pwd) throw new Error('Import annulé');
        let plain;
        try{ plain = await aesGcmDecryptToString(pwd, json); }
        catch(_){ throw new Error('Mot de passe incorrect ou fichier corrompu'); }
        json = JSON.parse(plain);
      }
      if (Array.isArray(json) && json.length && !('sections' in (json[0]||{})) && ('title' in (json[0]||{}))){
        json = [{ name:'Processus 1', enabled:true, sections: json }];
      }
      const ok=validateTemplate(json);
      if (!ok.valid) throw new Error('Modèle invalide : ' + ok.reason);

      PROCESSES = json.map(p=>({
        name: p.name || 'Processus',
        enabled: (p.enabled!==false),
        sections: (p.sections||[]).map(sec=>{
          const s={ title: sec.title || '', fields: [] };
          s.fields = (sec.fields||[]).map(it=>{
            if (it.group){
              const g = { __kind:'group', __uid:genUid(), name:it.group.name || tinyName(it.group.label || 'groupe'), label:it.group.label||'', required:!!it.group.required, repeatable:!!it.group.repeatable, nameAuto:false,
                fields:(it.fields||[]).map(f=>{ const ff={__kind:'field',...f,nameAuto:false}; if(!ff.name) ff.name=tinyName(ff.label||ff.name||'champ'); if(!ff.tips) ff.tips={icon:'',text:''}; return ff; }) };
              return g;
            }
            const f2={__kind:'field', ...it, nameAuto:false}; if(!f2.name) f2.name=tinyName(f2.label||f2.name||'champ'); if(!f2.tips) f2.tips={icon:'',text:''}; return f2;
          });
          return s;
        })
      }));
      currentProcess=0; currentSection=PROCESSES[0]?.sections?.length ? 0 : -1;
      save(); renderAll(); selectProcess(currentProcess); if (currentSection>=0) selectSection(currentSection);
      toast('Modèle importé');
    }catch(err){ alert('Import échoué : ' + (err?.message || err)); }
    finally{ e.target.value=''; }
  });

  $('#btnAddGroup').addEventListener('click', ()=>{
    if (currentSection<0) createSection();
    const sec = S()[currentSection];
    const arr = sec.fields || (sec.fields = []); // <-- corrige la syntaxe cassée
    const g = makeGroup(); g.label=''; g.name = uniqueName(tinyName('groupe'));
    arr.push(g);
    save(); renderAll(); selectSection(currentSection); toast('Groupe ajouté');
  });

  $('#btnGroupSelected')?.addEventListener('click', groupSelected);
  $('#btnUmlZip')?.addEventListener('click', exportAllUmlZIP);

  $('#btnAddFieldInGroup').addEventListener('click', ()=>{
    if (currentSection<0 || editingGroupIndex<0) return;
    const g = S()[currentSection].fields[editingGroupIndex];
    (g.fields || (g.fields=[])).push(makeField());
    const base = tinyName('champ');
    g.fields[g.fields.length-1].name = uniqueName(base);
    editingFieldIndex = g.fields.length - 1;
    renderFields(S()[currentSection].fields);
    save(); renderPreview();
  });
  
  $('#btnProcZip')?.addEventListener('click', exportProcessAsZip);

  // Protéger les checkboxes des clics de carte
  (function protectCheckboxes(){
    const area = $('#fieldList'); if (!area) return;
    const stop = e => { if (e.target && e.target.matches('input[type="checkbox"]')) e.stopPropagation(); };
    area.addEventListener('mousedown', stop, true);
    area.addEventListener('click', stop, true);
  })();

  buildIconPicker();
}

/* Boot */
function boot(){
  PROCESSES = load();
  if (!Array.isArray(PROCESSES) || !PROCESSES.length) PROCESSES = [ makeProcess() ];

  PROCESSES.forEach(p=>{
    if (typeof p.enabled === 'undefined') p.enabled = true;
    if (!Array.isArray(p.sections)) p.sections = [];
    p.sections = p.sections.map(sec=>{
      sec.fields = (sec.fields||[]).map(it=>{
        if (it.group){
          const g = { __kind:'group', __uid: it.__uid || genUid(), name:(it.group.name||tinyName(it.group.label||'groupe')), label:(it.group.label||''), required:!!it.group.required, repeatable:!!it.group.repeatable, nameAuto:false,
            fields:(it.fields||[]).map(f=>{ const ff={__kind:'field',...f,nameAuto:false}; if(!ff.name) ff.name=tinyName(ff.label||ff.name||'champ'); if(!ff.tips) ff.tips={icon:'',text:''}; return ff; }) };
          return g;
        }
        if (it.__kind==='group' || it.__kind==='field'){
          if (isGroup(it) && !it.__uid) it.__uid = genUid();
          if (isField(it) && !it.tips) it.tips = { icon:'', text:'' };
          return it;
        }
        const f = { __kind:'field', ...it, nameAuto:false };
        if (!f.name) f.name = tinyName(f.label || f.name || 'champ');
        if (!f.tips) f.tips = { icon:'', text:'' };
        return f;
      });
      return sec;
    });
  });

  ensureGroupUids();
  if (currentProcess>=PROCESSES.length) currentProcess=0;
  renderAll();
  selectProcess(currentProcess);
  if (S().length) selectSection(0); else selectSection(-1);
  updateOptionsVisibility();
  bindFieldInputsLive();

  // Ajuste la hauteur du header pour le layout plein écran
  (function fitHeader(){
    const set = ()=> {
      const h = document.querySelector('header')?.offsetHeight || 64;
      document.documentElement.style.setProperty('--header-h', h + 'px');
    };
    set();
    window.addEventListener('resize', set);
    window.addEventListener('load', set);
  })();
}

/* Init */
(function init(){
  bindGlobal();
  boot();
})();
</script>

</body>
</html>
