<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>!nsight-Factory ‚Äî Builder de mod√®le</title>
<script src="https://cdn.jsdelivr.net/npm/@zip.js/zip.js@2.7.48/dist/zip.min.js"></script>
<style>
/* ============ Th√®me clair + base ============ */
:root{
  --bg:#f6f7fb;
  --panel:#ffffff;
  --panel-2:#fafafa;
  --muted:#6b7280;
  --fg:#111827;

  --accent:#2563eb;     /* bleu */
  --accent-2:#14b8a6;   /* teal */
  --danger:#dc2626;
  --ok:#16a34a;

  --card-border:#e5e7eb;
  --shadow:0 6px 18px rgba(17,24,39,.08);
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font:15px/1.6 Inter, ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  color:var(--fg);
  background:var(--bg);
}

/* ============ En-t√™te ============ */
header{
  position:sticky; top:0; z-index:50;
  padding:12px clamp(12px,4vw,24px);
  border-bottom:1px solid var(--card-border);
  backdrop-filter:saturate(130%) blur(6px);
  background:rgba(255,255,255,.9);
  display:grid; grid-template-columns:auto 1fr; gap:12px; align-items:center;
}
header h1{margin:0; font-size:16px; font-weight:800; color:#0f172a}
header h1 .brand{color:var(--accent)}
.toolbar{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-start}

/* ============ Boutons ============ */
button,.btn{
  border:1px solid var(--card-border);
  background:var(--panel);
  color:var(--fg);
  padding:10px 12px;
  border-radius:10px;
  cursor:pointer;
  transition:background .15s ease, transform .05s ease, border-color .15s ease, box-shadow .15s ease;
}
button:hover{background:#f3f4f6}
button:active{transform:translateY(1px)}
button:focus-visible{outline:2px solid var(--accent); outline-offset:2px}

.primary{background:var(--accent); border-color:var(--accent); color:#fff; font-weight:700}
.primary:hover{filter:brightness(0.95)}
.danger{background:#fee2e2; border-color:#fecaca; color:#991b1b}
.danger:hover{background:#fecaca}
.ok{background:#dcfce7; border-color:#bbf7d0; color:#166534}
.ok:hover{background:#bbf7d0}
.ghost{background:transparent}
.icon{font-style:normal; opacity:.9; margin-right:6px}

/* ============ Champs de formulaire ============ */
input[type="text"],input[type="number"],select,textarea{
  width:100%;
  padding:10px 12px;
  border:1px solid var(--card-border);
  background:var(--panel);
  color:var(--fg);
  border-radius:10px;
  outline:none;
}
input:focus,select:focus,textarea:focus{
  border-color:var(--accent);
  box-shadow:0 0 0 3px rgba(37,99,235,.12);
}
textarea{min-height:90px; resize:vertical; white-space:pre-wrap}

/* ============ Layout & panneaux ============ */
.wrap{
  display:grid;
  grid-template-columns:1fr;
  gap:12px;
  padding:12px;
}
.panel{
  background:var(--panel);
  border:1px solid var(--card-border);
  border-radius:14px;
  padding:14px;
  box-shadow:var(--shadow);
}
.panel h2{
  margin:2px 0 10px 0;
  font-size:13px;
  color:#334155;
  font-weight:600;
  letter-spacing:.2px;
}

@media (min-width:1100px){
  .wrap{grid-template-columns:360px 1fr; gap:16px; padding:16px}
  header{grid-template-columns:auto 1fr; gap:18px}
  .toolbar{justify-content:flex-start}
}

/* ============ Listes & cartes ============ */
.list,.fields{display:flex; flex-direction:column; gap:8px}

.proc-item,.section-item,.field-item{
  border:1px solid var(--card-border);
  background:var(--panel);
  padding:10px;
  border-radius:12px;
  display:flex; gap:10px; align-items:center;
  transition:background .15s ease, border-color .15s ease, box-shadow .15s ease;
}
.proc-item:hover,.section-item:hover,.field-item:hover{
  background:var(--panel-2);
  border-color:#d1d5db;
}
.proc-item .title,.section-item .title{flex:1; font-weight:700}
.field-item .meta{flex:1}

.drag{cursor:grab; color:#94a3b8}
.proc-item.dragging,.section-item.dragging,.field-item.dragging{opacity:.6; outline:2px dashed #93c5fd}
.proc-item.disabled{opacity:.5; filter:saturate(.7)}

/* ============ Grilles (lignes de formulaire) ============ */
.row{display:grid; grid-template-columns:1fr; gap:8px}
.row3{display:grid; grid-template-columns:1fr; gap:8px}
@media (min-width:720px){
  .row{grid-template-columns:1fr 1fr}
  .row3{grid-template-columns:2fr 1fr 1fr}
}

/* ============ Utilitaires ============ */
.muted{color:var(--muted)}
.pill{
  font-size:12px; padding:2px 8px; border-radius:999px;
  background:#f3f4f6; border:1px solid var(--card-border); color:#374151
}
.right{margin-left:auto; display:flex; gap:6px; flex-wrap:wrap}
.hr{height:1px; background:var(--card-border); margin:10px 0}
.preview pre{
  margin:0; padding:10px; background:#f8fafc;
  border:1px solid var(--card-border); border-radius:10px; color:#111827;
  overflow:auto; max-height:40vh; font-size:13px; line-height:1.5;
}
.inline{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
.hidden{display:none !important}
.fab{
  position:fixed; right:16px; bottom:16px; z-index:60;
  padding:12px 14px; border-radius:999px; border:1px solid var(--accent);
  background:var(--accent); color:#fff; box-shadow:var(--shadow)
}
.toast{
  position:fixed; left:50%; bottom:24px; transform:translateX(-50%) translateY(20px);
  opacity:0; pointer-events:none; background:#111827; color:#fff;
  border:1px solid rgba(255,255,255,.08); padding:10px 12px; border-radius:12px;
  transition:.2s ease; z-index:70; font-size:13px
}
.toast.show{opacity:1; transform:translateX(-50%) translateY(0)}
.sticky-add{
  position:sticky; bottom:0; padding:10px 0 0 0; margin-top:10px;
  background:linear-gradient(180deg, rgba(255,255,255,0), rgba(255,255,255,.95));
  backdrop-filter:saturate(140%) blur(4px); border-top:1px solid var(--card-border)
}
.sticky-add .btn{width:100%}

/* ============ Groupes (conteneurs de champs) ============ */
.group-item{
  border:1px solid var(--card-border);
  background:#ffffff;
  padding:10px; border-radius:12px;
}
.group-head{display:flex; align-items:center; gap:10px}
.group-title{font-weight:800}
.group-meta{color:#475569}
.group-fields{
  display:flex; flex-direction:column; gap:8px; margin-top:8px;
  padding:8px; border:1px dashed #cbd5e1; border-radius:10px; background:#f8fafc
}
.select-box{margin-right:6px}

/* ============ DnD (surbrillance de drop) ============ */
.drop-target{outline:2px dashed var(--accent); outline-offset:2px}
.drop-before{border-top:2px solid var(--accent)}

/* ============ Tips (astuces de champ) ============ */
.tip-editor{
  background:var(--panel-2);
  border:1px dashed var(--card-border);
  border-radius:12px;
  padding:12px;
}
.tip-toolbar{display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top:8px}
.tip-preview{
  margin-top:10px;
  display:flex; gap:10px; align-items:flex-start;
  background:#f8fafc;
  border:1px solid var(--card-border);
  border-radius:10px;
  padding:10px;
  min-height:44px;
  color:var(--fg);
  white-space:normal;
}
.tip-preview .tip-icon{
  font-size:24px; line-height:1; width:28px; text-align:center; flex:0 0 28px;
}
.tip-preview .tip-text a{
  text-decoration:underline;
  word-break:break-word;
}

/* ============ Icon picker ============ */
.icon-picker{
  position:relative;
}
.icon-grid{
  position:absolute; top:100%; left:0; margin-top:6px;
  background:#fff; border:1px solid var(--card-border); border-radius:12px;
  box-shadow:var(--shadow);
  padding:8px; display:grid; grid-template-columns:repeat(8, 28px); gap:6px;
  width:max-content; max-width:320px; z-index:40;
}
.icon-grid button{
  width:28px; height:28px; border:1px solid #e5e7eb; border-radius:8px; background:#fff; cursor:pointer;
  font-size:18px; line-height:1; display:flex; align-items:center; justify-content:center;
}
.icon-grid button:hover{background:#f3f4f6}
.icon-grid.hidden{display:none}

/* ============ √âtats d'accessibilit√© ============ */
button[disabled], .btn[disabled]{opacity:.6; cursor:not-allowed}

/* ===== Modales (mot de passe / avertissement) ===== */
.modal-backdrop{
  position:fixed; inset:0; background:rgba(0,0,0,.35);
  display:none; align-items:center; justify-content:center; z-index:90;
}
.modal{
  width:min(520px, 92vw); background:var(--panel); border:1px solid var(--card-border);
  border-radius:14px; box-shadow:var(--shadow); padding:16px;
}
.modal h3{ margin:0 0 8px; font-size:16px }
.modal p{ margin:4px 0 10px; color:var(--muted) }
.modal .row{ display:flex; gap:8px; align-items:center }
.modal .actions{ display:flex; gap:8px; justify-content:flex-end; margin-top:12px }
.modal input[type="password"], .modal input[type="text"]{ width:100% }
.modal-backdrop.show{ display:flex }

/* Anti-overflow global pour les layouts flex/grid */
* { box-sizing: border-box; min-width: 0 }

/* Conteneur central fluide, √©vite l'√©tirement hors √©cran */
.wrap{
  display:grid;
  grid-template-columns:1fr;
  gap:12px;
  padding:12px;
  width: min(1200px, 100%);
  margin-inline: auto;
}

/* Emp√™che les √©l√©ments flex de forcer l'√©largissement */
.inline, .toolbar, header { min-width: 0 }

/* Les panels ne d√©bordent pas et peuvent scroller si besoin */
.panel { overflow: hidden }

/* Les listes prennent bien la largeur dispo sans pousser le grid */
.list,.fields { min-width: 0 }

/* Le header s‚Äôadapte mieux sur petits √©crans */
.toolbar{display:flex; gap:8px; flex-wrap:wrap; align-items:center; justify-content:flex-start; min-width:0}

/* Pr√©servation de l‚Äôaper√ßu sans d√©border horizontalement */
.preview pre{ max-width:100%; overflow:auto }

@media (min-width:1100px){
  /* Emp√™che le scroll global ; on scrollera √† l‚Äôint√©rieur des colonnes */
  html, body { height:100%; overflow:hidden; }

  /* 2 colonnes plein √©cran sous le header */
  .wrap{
    grid-template-columns: 360px 1fr;     /* colonne gauche fixe */
    height: calc(100vh - var(--header-h, 64px)); /* remplit l‚Äô√©cran dispo */
    overflow: hidden;                     /* pas de d√©bordement horizontal */
  }

  /* Colonne gauche = pile de panneaux scrollables */
  .left-col{
    display:flex; flex-direction:column; gap:16px;
    min-height:0; overflow:hidden;
  }
  .left-col .panel{
    flex:1; min-height:0; overflow:auto; /* chaque panel peut scroller si long */
  }

  /* Panneau de droite occupe toute la hauteur et scrolle en interne */
  .main-panel{
    height:100%; min-height:0; overflow:auto;
    display:block; /* garde ton flux interne tel quel */
  }

  /* S√©curit√© anti-d√©bordement horizontal */
  .panel, .list, .fields, .inline, header { min-width:0 }
  .preview pre{ max-width:100%; overflow:auto } /* tu l‚Äôavais, on garde */
}

</style>
</head>
<body>
  <header>
    <div class="inline">
      <h1><span class="brand">!nsight-Factory</span></h1>
    </div>
    <div class="toolbar">
      <label class="btn ghost inline" for="fileImport" style="cursor:pointer"><span class="icon">üì•</span>Importer JSON</label>
      <input id="fileImport" type="file" accept="application/json,.json" class="hidden">
      <button class="btn" id="btnExport"><span class="icon">üíæ</span>Exporter JSON</button>
      <button class="btn primary" id="btnCopy"><span class="icon">üìã</span>Copier le JSON</button>
      <button class="btn" id="btnUmlZip"><span class="icon">üß©</span>Sch√©ma UML (ZIP)</button>
    </div>
  </header>

  <div class="wrap">
    <div class="left-col">
      <div class="panel">
        <h2>Processus</h2>
        <div id="processList" class="list" aria-label="Liste des processus"></div>
        <div class="hr"></div>
        <div class="inline" style="justify-content:space-between">
          <div class="muted">Glissez pour r√©ordonner. Activez/D√©sactivez pour inclure/retirer du JSON.</div>
          <button class="btn ok" id="btnNewProcess"><span class="icon">‚ûï</span>Nouveau processus</button>
        </div>
      </div>

      <div class="panel">
        <h2>Parties (sections) du processus actif</h2>
        <div id="sectionList" class="list" aria-label="Liste des sections"></div>
        <div class="hr"></div>
        <div class="inline" style="justify-content:space-between">
          <div class="muted">Glissez pour r√©ordonner. Cliquez pour √©diter.</div>
          <button class="btn" id="btnNewSection"><span class="icon">‚ûï</span>Nouvelle partie</button>
        </div>
      </div>
    </div>

    <div class="panel">
      <div id="processEditor" class="hidden" aria-live="polite">
        <h2>√âdition du processus</h2>
        <div class="row" style="margin-bottom:8px">
          <div>
            <label class="small">Nom du processus</label>
            <input id="procName" type="text" placeholder="Ex: Processus d‚Äôinscription">
          </div>
        </div>
        <div class="hr"></div>
      </div>

      <h2 id="editorTitle" class="muted">Aucune partie s√©lectionn√©e</h2>

      <div id="editorArea" class="hidden" aria-live="polite">
        <div class="row">
          <div>
            <label class="small">Titre de la partie</label>
            <input id="secTitle" type="text" placeholder="Ex: Informations g√©n√©rales">
          </div>
          <div class="inline" style="align-items:end; justify-content:flex-end">
            <button class="btn danger" id="btnDeleteSection">Supprimer la partie</button>
          </div>
        </div>

        <div class="hr"></div>

        <div class="row3">
          <div><label class="small">Nom du champ</label><input id="fldName" type="text" placeholder="Saisir le libell√© du champ"></div>
          <div>
            <label class="small">Type</label>
            <select id="fldType">
              <option value="text">text</option>
              <option value="textarea">textarea</option>
              <option value="number">number</option>
              <option value="date">date</option>
              <option value="checkbox">checkbox</option>
              <option value="radio">radio</option>
              <option value="select">select</option>
              <option value="file">file</option>
            </select>
          </div>
          <div><label class="small">Label (apercu)</label><input id="fldLabel" type="text" placeholder="Reprend exactement le 'Nom du champ'"></div>
        </div>
        <div class="row">
          <div>
            <label class="small">Obligatoire ?</label>
            <select id="fldRequired"><option value="false">Non</option><option value="true">Oui</option></select>
          </div>
          <div>
            <label class="small">R√©p√©table ?</label>
            <select id="fldRepeatable"><option value="false">Non</option><option value="true">Oui</option></select>
          </div>
        </div>
        <div class="row" id="rowOptions" style="margin-top:8px">
          <div>
            <label class="small">Options (radio/select) ‚Äî s√©par√©es par des virgules</label>
            <input id="fldOptions" type="text" placeholder="Oui, Non">
          </div>
          <div class="inline" style="align-items:end; justify-content:flex-end">
            <button class="btn ok" id="btnAddFieldTop"><span class="icon">‚ûï</span>Ajouter un champ</button>
          </div>
        </div>

        <!-- Tips (astuces) -->
        <div class="hr"></div>
        <div class="tip-editor">
          <div class="muted">Astuce (facultatif) ‚Äî texte riche (liens auto) + grosse ic√¥ne. Le texte peut √™tre <strong>multiligne</strong>.</div>

          <div class="tip-toolbar">
            <div class="icon-picker">
              <button class="btn" id="btnToggleIconPicker" type="button">üéØ Choisir une ic√¥ne</button>
              <div id="iconGrid" class="icon-grid hidden" role="dialog" aria-label="Choisir une ic√¥ne">
                <!-- peu d‚Äôic√¥nes ‚Äúpr√™tes‚Äù pour la rapidit√© -->
              </div>
            </div>

            <div style="min-width:240px; flex:1">
              <label class="small">Ic√¥ne (libre ou via la grille) ‚Äî emoji/texte</label>
              <input id="fldTipsIcon" type="text" placeholder="Ex: üí°, üìé, ‚ÑπÔ∏è" maxlength="8" list="iconDatalist">
              <datalist id="iconDatalist"></datalist>
            </div>
          </div>

          <div style="margin-top:8px">
            <label class="small">Texte de l‚Äôastuce (liens reconnus ; retours √† la ligne conserv√©s)</label>
            <textarea id="fldTips" placeholder="Ex: 1) Consultez https://docs.exemple.com\n2) √âcrivez √† support@exemple.com"></textarea>
          </div>

          <div class="tip-preview" id="fldTipsPreview" aria-live="polite"></div>
        </div>

        <div class="inline" style="gap:8px; margin:6px 0 2px">
          <button class="btn ok" id="btnAddGroup"><span class="icon">üóÇÔ∏è</span>Nouveau groupe</button>
          <button class="btn" id="btnGroupSelected"><span class="icon">üì¶</span>Grouper la s√©lection</button>
        </div>

        <div class="hr"></div>
        <div class="inline" style="justify-content:space-between">
          <div class="muted">Champs et groupes de cette partie</div>
          <div class="inline">
            <button class="btn" id="btnFieldUp" title="Monter l‚Äô√©l√©ment en √©dition">‚¨ÜÔ∏è</button>
            <button class="btn" id="btnFieldDown" title="Descendre l‚Äô√©l√©ment en √©dition">‚¨áÔ∏è</button>
          </div>
        </div>
        <div id="fieldList" class="fields" aria-label="Items de la section"></div>
        <div class="sticky-add">
          <button class="btn ok" id="btnAddFieldSticky"><span class="icon">‚ûï</span>Ajouter un champ</button>
        </div>

        <div id="groupEditor" class="hidden" style="margin-top:10px">
          <div class="hr"></div>
          <div class="inline" style="justify-content:space-between">
            <div class="muted">√âdition du groupe</div>
            <button class="btn danger" id="btnDeleteGroup">Supprimer le groupe</button>
          </div>
          <div class="row3" style="margin-top:8px">
            <div><label class="small">Nom technique</label><input id="grpName" type="text" placeholder="auto: ultra-court"></div>
            <div><label class="small">Label</label><input id="grpLabel" type="text" placeholder="Label du groupe"></div>
            <div class="inline" style="gap:8px">
              <div style="flex:1">
                <label class="small">Obligatoire ?</label>
                <select id="grpRequired"><option value="false">Non</option><option value="true">Oui</option></select>
              </div>
              <div style="flex:1">
                <label class="small">R√©p√©table ?</label>
                <select id="grpRepeatable"><option value="false">Non</option><option value="true">Oui</option></select>
              </div>
            </div>
          </div>
          <div class="inline" style="justify-content:flex-end; margin-top:8px">
            <button class="btn ok" id="btnAddFieldInGroup"><span class="icon">‚ûï</span>Ajouter un champ dans ce groupe</button>
          </div>
        </div>
      </div>

      <div class="hr"></div>
      <div class="preview">
        <div class="inline" style="justify-content:space-between; margin-bottom:6px">
          <div class="muted">Aper√ßu JSON (live) ‚Äî seuls les processus <strong>activ√©s</strong> sont export√©s</div>
          <div>
            <span class="pill" id="countProcesses">0 processus</span>
            <span class="pill" id="countSections">0 parties</span>
            <span class="pill" id="countFields">0 items</span>
          </div>
        </div>
        <pre id="jsonPreview">[]</pre>
      </div>
    </div>
  </div>

  <button class="fab primary" id="fabAdd"><span class="icon">‚ûï</span>Processus</button>
  <div id="toast" class="toast" role="status" aria-live="polite"></div>

<!-- Modale g√©n√©rique -->
<div id="modalHost" class="modal-backdrop" role="dialog" aria-modal="true">
  <div class="modal" role="document">
    <h3 id="modalTitle">Titre</h3>
    <p id="modalText">Texte</p>
    <div id="modalInputRow" class="row hidden">
      <input id="modalInput" type="password" placeholder="Mot de passe" autocomplete="current-password">
    </div>
    <div class="actions">
      <button class="btn" id="modalCancel">Annuler</button>
      <button class="btn primary" id="modalOk">OK</button>
    </div>
  </div>
</div>

<script>
/* --- √âtat global & helpers --- */
let PROCESSES = [];
let currentProcess = 0;
let currentSection = -1;
let editingFieldIndex = -1;
let editingGroupIndex = -1;

const DND_MIME = 'application/x-json-item';

const $  = (sel, root=document)=> root.querySelector(sel);
const $$ = (sel, root=document)=> [...root.querySelectorAll(sel)];
const save = ()=> localStorage.setItem('templateBuilderV2', JSON.stringify(PROCESSES));
const load = ()=> { try{ const raw = localStorage.getItem('templateBuilderV2'); return raw ? JSON.parse(raw) : []; }catch(_){ return []; } };
const isOptType = t => (t==='radio' || t==='select');
const toast = (msg)=>{ const t = $('#toast'); t.textContent = msg; t.classList.add('show'); setTimeout(()=> t.classList.remove('show'), 1200); };
const isField = o => o && o.__kind === 'field';
const isGroup = o => o && o.__kind === 'group';
const P = ()=> PROCESSES[currentProcess] || null;
const S = ()=> (P()?.sections) || [];

/* --- UID groupes --- */
let __gid_inc = 1;
function genUid(){ try{ return crypto.randomUUID(); }catch(_){ return 'g'+(__gid_inc++); } }

// Base64 util (binaire-s√ªr)
function b64encode(u8){ let s='',c=0x8000; for(let i=0;i<u8.length;i+=c){ s+=String.fromCharCode.apply(null,u8.subarray(i,i+c)); } return btoa(s); }
function b64decode(b){ const bin=atob(b); const u8=new Uint8Array(bin.length); for(let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i); return u8; }

// Prompts de modale
function openModal({title, text, password=false, placeholder='Mot de passe', okText='OK'}){
  return new Promise(resolve=>{
    const host = document.getElementById('modalHost');
    const t = document.getElementById('modalTitle');
    const p = document.getElementById('modalText');
    const row = document.getElementById('modalInputRow');
    const inp = document.getElementById('modalInput');
    const ok = document.getElementById('modalOk');
    const cancel = document.getElementById('modalCancel');
    t.textContent = title||'';
    p.textContent = text||'';
    row.classList.toggle('hidden', !password);
    inp.type = password ? 'password' : 'text';
    inp.value = '';
    inp.placeholder = placeholder;
    ok.textContent = okText;
    const close=(val)=>{ host.classList.remove('show'); resolve(val); };
    ok.onclick = ()=> close(password ? inp.value : true);
    cancel.onclick = ()=> close(null);
    host.classList.add('show');
    setTimeout(()=> password ? inp.focus() : ok.focus(), 0);
  });
}
const promptPassword = (title='Mot de passe requis', text='Saisissez le mot de passe.') =>
  openModal({title, text, password:true, okText:'Valider'});

const confirmWarning = (title, text, okText='Oui, continuer') =>
  openModal({title, text, password:false, okText});

/* --- WebCrypto: PBKDF2 + AES-GCM --- */
async function deriveAesKey(password, saltU8, iterations=200000){
  const enc = new TextEncoder();
  const baseKey = await crypto.subtle.importKey('raw', enc.encode(password), {name:'PBKDF2'}, false, ['deriveKey']);
  return crypto.subtle.deriveKey(
    {name:'PBKDF2', salt: saltU8, iterations, hash:'SHA-256'},
    baseKey,
    {name:'AES-GCM', length:256},
    false,
    ['encrypt','decrypt']
  );
}
async function aesGcmEncryptFromString(password, plain){
  const enc = new TextEncoder();
  const data = enc.encode(plain);
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv   = crypto.getRandomValues(new Uint8Array(12));
  const key  = await deriveAesKey(password, salt);
  const ct   = new Uint8Array(await crypto.subtle.encrypt({name:'AES-GCM', iv}, key, data));
  return {
    format: 'IF-AESGCM-v1',
    kdf: 'PBKDF2', hash:'SHA-256', iter: 200000,
    salt: b64encode(salt),
    iv:   b64encode(iv),
    ct:   b64encode(ct)
  };
}
async function aesGcmDecryptToString(password, pack){
  if (!pack || pack.format!=='IF-AESGCM-v1') throw new Error('Format inconnu');
  const salt = b64decode(pack.salt);
  const iv   = b64decode(pack.iv);
  const ct   = b64decode(pack.ct);
  const key  = await deriveAesKey(password, salt, pack.iter||200000);
  const pt   = new Uint8Array(await crypto.subtle.decrypt({name:'AES-GCM', iv}, key, ct));
  return new TextDecoder().decode(pt);
}

/* --- Noms courts --- */
function tinyName(str, max = 6){
  if (!str) return 'i';
  let s = String(str).normalize('NFD').replace(/\p{Diacritic}/gu,'').toLowerCase().replace(/[^a-z0-9\s]/g,' ').trim();
  if (!s) return 'i';
  const words = s.split(/\s+/).filter(Boolean);
  let out = words.map(w=>w[0]).join('');
  if (out.length<2){ const w = words[0]||s; const cons = w.replace(/[aeiou]/g,''); out = (w[0]||'') + (cons.slice(1) || w.slice(1)); }
  if (out.length<2) out = s.replace(/\s+/g,'');
  out = out.slice(0,max);
  return out || 'i';
}
function uniqueName(base){
  const used = new Set();
  S().forEach(sec=>{
    (sec.fields||[]).forEach(it=>{
      if (isGroup(it) && it.name) used.add(it.name);
      if (isField(it) && it.name) used.add(it.name);
      if (isGroup(it)) (it.fields||[]).forEach(f=>{ if (f.name) used.add(f.name); });
    });
  });
  let name = base || 'i';
  if (!used.has(name)) return name;
  let n=2; while(used.has(`${name}-${n}`)) n++;
  return `${name}-${n}`;
}

/* --- Fabriques --- */
function makeField(){
  return {
    __kind:'field',
    name:'', type:'text', label:'',
    required:false, repeatable:false, options:[],
    nameAuto:true,
    tips: { icon:'', text:'' }
  };
}
function makeGroup(){ return { __kind:'group', __uid:genUid(), name:'', label:'', required:false, repeatable:false, fields:[], nameAuto:true }; }
function makeSection(){ return { title:'Nouvelle partie', fields:[] }; }
function makeProcess(){ return { name:`Processus ${PROCESSES.length+1}`, enabled:true, sections:[] }; }

function insertFieldInGroupByUid(gid, field, beforeIdx=null){
  const { group } = findGroupByUid(gid);
  if (!group) return;
  const arr = group.fields || (group.fields = []);
  const at = (beforeIdx==null || beforeIdx<0 || beforeIdx>arr.length) ? arr.length : beforeIdx;
  arr.splice(at, 0, field);
}

/* --- Group helper --- */
function findGroupByUid(uid){
  const arr = S()[currentSection]?.fields || [];
  const idx = arr.findIndex(g => isGroup(g) && g.__uid === uid);
  return { index: idx, group: arr[idx] };
}

/* --- DnD protection --- */
let _dropBusy = false;
function beginDrop(e){ if (_dropBusy) return false; _dropBusy = true; e?.preventDefault?.(); e?.stopPropagation?.(); e?.stopImmediatePropagation?.(); return true; }
function endDrop(){ requestAnimationFrame(()=>{ save(); renderAll(); selectSection(currentSection); _dropBusy=false; }); }
let _justDroppedAt = 0; function markDrop(){ _justDroppedAt = performance.now(); } function isRecentDrop(){ return performance.now() - _justDroppedAt < 150; }

/* --- Linkify + multilignes --- */
function linkifyRaw(text){
  if (!text) return '';
  let t = String(text)
    .replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')
    .replace(/"/g,'&quot;').replace(/'/g,'&#39;');
  t = t.replace(/(\bhttps?:\/\/[^\s<]+)/gi, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');
  t = t.replace(/([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})/g, '<a href="mailto:$1">$1</a>');
  t = t.replace(/\r?\n/g, '<br>'); // << pr√©serve les retours √† la ligne
  return t;
}
function updateTipsPreview(f){
  const prev = $('#fldTipsPreview'); if (!prev) return;
  const icon = (f.tips?.icon)||'';
  const text = (f.tips?.text)||'';
  const html = `
    <div class="tip-icon">${icon || 'üí°'}</div>
    <div class="tip-text">${linkifyRaw(text) || '<span class="muted">Aucune astuce</span>'}</div>
  `;
  prev.innerHTML = html;
}

/* --- Ouvre l'√©diteur champ --- */
function openFieldEditor(f){
  const area = $('#editorArea'); area?.classList.remove('hidden');
  $('#groupEditor')?.classList.add('hidden');
  $('#fldName').value = f.label || '';
  $('#fldLabel').value = f.label || '';
  $('#fldType').value = f.type || 'text';
  $('#fldRequired').value = f.required ? 'true' : 'false';
  $('#fldRepeatable').value = f.repeatable ? 'true' : 'false';
  $('#fldOptions').value = (Array.isArray(f.options)? f.options : []).join(', ');
  // Tips
  $('#fldTipsIcon').value = (f.tips?.icon)||'';
  $('#fldTips').value = (f.tips?.text)||'';
  updateTipsPreview(f);

  updateOptionsVisibility();
  $('#fldName').focus();
}

/* --- Rendu processus --- */
function renderProcesses(){
  const list = $('#processList');
  list.innerHTML = '';

  PROCESSES.forEach((proc, i) => {
    const item = document.createElement('div');
    item.className = 'proc-item' + (proc.enabled ? '' : ' disabled');
    item.draggable = true;
    item.dataset.index = i;

    const actLabel = proc.enabled ? 'D√©sactiver' : 'Activer';

    item.innerHTML = `
      <div class="drag" title="Glisser pour r√©organiser">‚ãÆ‚ãÆ</div>
      <div class="title">${proc.name || '(sans nom)'}</div>
      <span class="pill">${(proc.sections || []).length} partie(s)</span>
      <div class="right">
        <button class="btn" data-act="toggle">${actLabel}</button>
        <button class="btn" data-act="edit">√âditer</button>
        <button class="btn danger" data-act="del">Supprimer</button>
      </div>
    `;

    item.addEventListener('click', (e) => {
      const act = e.target.closest('button')?.dataset?.act || 'edit';
      if (act === 'edit') {
        selectProcess(i);
        $('#processEditor')?.scrollIntoView({ behavior: 'smooth' });
      } else if (act === 'toggle') {
        PROCESSES[i].enabled = !PROCESSES[i].enabled;
        save(); renderAll(); renderPreview();
      } else if (act === 'del') {
        if (PROCESSES.length <= 1) {
          toast('Au moins un processus est requis');
          return;
        }
        if (confirm('Supprimer ce processus ?')) {
          PROCESSES.splice(i, 1);
          if (currentProcess >= PROCESSES.length) currentProcess = PROCESSES.length - 1;
          currentSection = -1;
          save(); renderAll(); selectProcess(currentProcess);
        }
      }
    });

    item.addEventListener('dragstart', (e) => {
      item.classList.add('dragging');
      e.dataTransfer.setData('text/plain', i);
      e.dataTransfer.effectAllowed = 'move';
    });

    item.addEventListener('dragend', () => item.classList.remove('dragging'));

    item.addEventListener('dragover', (e) => {
      const isReorder =
        e.dataTransfer.types.includes('text/plain') &&
        !e.dataTransfer.types.includes(DND_MIME);
      if (!isReorder) return;
      e.preventDefault();
      e.stopPropagation();
      item.classList.add('drop-target');
    });

    item.addEventListener('dragleave', (e) => {
      e.stopPropagation();
      item.classList.remove('drop-target');
    });

    item.addEventListener('drop', (e) => {
      // Ne g√©rer ici QUE le r√©ordonnancement (text/plain), pas les items
      if (!e.dataTransfer.types.includes('text/plain') || e.dataTransfer.types.includes(DND_MIME)) return;
      e.preventDefault();
      const from = +e.dataTransfer.getData('text/plain');
      const to = i;
      if (!Number.isInteger(from) || from === to) return;
      const [m] = PROCESSES.splice(from, 1);
      PROCESSES.splice(to, 0, m);
      currentProcess = to;
      save(); renderAll(); selectProcess(currentProcess);
    });

    if (i === currentProcess) item.style.outline = '2px solid var(--accent-2)';
    list.appendChild(item);
  }); 
} 


/* --- Rendu sections --- */
/* --- Rendu sections --- */
function renderSections(){
  const list = $('#sectionList'); list.innerHTML = '';
  const sections = S();
  sections.forEach((sec,i)=>{
    const item = document.createElement('div');
    item.className = 'section-item'; item.draggable = true; item.dataset.index = i;
    item.innerHTML = `
      <div class="drag" title="Glisser pour r√©organiser">‚ãÆ‚ãÆ</div>
      <div class="title">${sec.title || '(sans titre)'}</div>
      <span class="pill">${(sec.fields||[]).length} item(s)</span>
      <div class="right">
        <button class="btn" data-act="up" title="Monter">‚¨ÜÔ∏è</button>
        <button class="btn" data-act="down" title="Descendre">‚¨áÔ∏è</button>
        <button class="btn" data-act="edit">√âditer</button>
        <button class="btn danger" data-act="del">Supprimer</button>
      </div>`;

    item.addEventListener('click',(e)=>{
      const act = e.target.closest('button')?.dataset?.act || 'edit';
      if (act==='edit'){ selectSection(i); }
      else if (act==='del'){ if(confirm('Supprimer cette partie ?')){ sections.splice(i,1); selectSection(-1); save(); renderAll(); } }
      else if (act==='up'){ if(i>0){ const [m]=sections.splice(i,1); sections.splice(i-1,0,m); save(); renderAll(); selectSection(i-1); } }
      else if (act==='down'){ if(i<sections.length-1){ const [m]=sections.splice(i,1); sections.splice(i+1,0,m); save(); renderAll(); selectSection(i+1); } }
    });

    item.addEventListener('dragstart',(e)=>{ item.classList.add('dragging'); e.dataTransfer.setData('text/plain', i); e.dataTransfer.effectAllowed='move'; });
    item.addEventListener('dragend',()=> item.classList.remove('dragging'));

    // Autoriser le drop d‚Äôitems (field/group) AVANT cette section
    item.addEventListener('dragover', (e) => {
      const isReorder =
        e.dataTransfer.types.includes('text/plain') &&
        !e.dataTransfer.types.includes(DND_MIME);
      if (!isReorder) return;
      e.preventDefault();
      e.stopPropagation();
      item.classList.add('drop-target');
    });

    item.addEventListener('dragleave', (e)=>{ e.stopPropagation(); item.classList.remove('drop-target'); });
    item.addEventListener('drop', (e)=>{
      // Ici: seulement r√©ordonnancement des sections (text/plain), pas le contenu d‚Äôune section
      if (!e.dataTransfer.types.includes('text/plain') || e.dataTransfer.types.includes(DND_MIME)) return;
      e.preventDefault();
      const from = +e.dataTransfer.getData('text/plain'); const to = i;
      if (!Number.isInteger(from) || from===to) return;
      const [m]=sections.splice(from,1); sections.splice(to,0,m);
      save(); renderAll(); selectSection(to);
    });

    list.appendChild(item);
  });
}

/* --- S√©lection contexte --- */
function selectProcess(i){
  currentProcess = i;
  currentSection = -1; editingFieldIndex = -1; editingGroupIndex = -1;
  renderProcesses(); renderSections();
  const pe = $('#processEditor');
  const ea = $('#editorArea');
  $('#editorTitle').textContent = 'Aucune partie s√©lectionn√©e';
  ea.classList.add('hidden');
  if (pe){
    pe.classList.remove('hidden');
    const input = $('#procName');
    input.value = P()?.name || '';
    input.oninput = (e)=>{ if (P()){ P().name = e.target.value; save(); renderProcesses(); renderPreview(); } };
  }
  renderPreview();
}
function selectSection(i){
  currentSection = i;
  const title = $('#editorTitle');
  const area  = $('#editorArea');
  const pe = $('#processEditor');
  editingFieldIndex = -1; editingGroupIndex = -1;
  if (pe) pe.classList.add('hidden');
  if (i<0){ title.textContent='Aucune partie s√©lectionn√©e'; area.classList.add('hidden'); renderFields([]); return; }
  title.textContent = '√âdition de la partie';
  area.classList.remove('hidden');
  $('#secTitle').value = S()[i].title || '';
  renderFields(S()[i].fields || []);
  bindSectionInputs();
  bindAddButtons();
  renderPreview();
}
function bindSectionInputs(){
  $('#secTitle').oninput = (e)=>{
    if (currentSection<0) return;
    S()[currentSection].title = e.target.value;
    save(); renderSections(); renderPreview();
  };
}
function refreshFieldUI(){ if (currentSection<0) return; renderFields(S()[currentSection].fields || []); }

/* --- DnD take/insert --- */
function getProcess(idx){ return PROCESSES[idx] || null; }
function getSection(procIdx, secIdx){
  const p = getProcess(procIdx); return (p && p.sections && p.sections[secIdx]) || null;
}

/* Retire un item (field ou group) de sa source et le retourne */
function takeItemFrom(payload){
  const {kind, from, proc, sec, gi, fi, gid} = payload || {};
  const section = getSection(proc, sec); if (!section) return null;

  if (kind === 'field'){
    if (from === 'group'){
      const g = section.fields?.[gi];
      if (!g || !isGroup(g)) return null;
      const arr = g.fields || [];
      const [m] = arr.splice(fi, 1);
      return isField(m) ? m : null;
    } else { // root
      const arr = section.fields || [];
      const [m] = arr.splice(fi, 1);
      return isField(m) ? m : null;
    }
  }

  if (kind === 'group' && from === 'root'){
    const arr = section.fields || [];
    const [m] = arr.splice(gi, 1);
    return isGroup(m) ? m : null;
  }

  return null;
}

/* Ins√®re un FIELD √† la racine d‚Äôune section (avant l‚Äôindex si fourni) */
function insertFieldAtRoot(procIdx, secIdx, field, beforeIdx=null){
  const sec = getSection(procIdx, secIdx); if (!sec) return;
  const arr = sec.fields || (sec.fields = []);
  const at = (beforeIdx==null || beforeIdx<0 || beforeIdx>arr.length) ? arr.length : beforeIdx;
  arr.splice(at, 0, field);
}

/* Ins√®re un GROUP √† la racine d‚Äôune section (avant l‚Äôindex si fourni) */
function insertGroupAtRoot(procIdx, secIdx, group, beforeIdx=null){
  const sec = getSection(procIdx, secIdx); if (!sec) return;
  const arr = sec.fields || (sec.fields = []);
  const at = (beforeIdx==null || beforeIdx<0 || beforeIdx>arr.length) ? arr.length : beforeIdx;
  arr.splice(at, 0, group);
}

/* --- Rendu items (root + groupes) --- */
function renderFields(items){
  const box = $('#fieldList'); box.innerHTML = '';

  if (!box._dndBound){
    // Drop √† la racine de la section (avant un item survol√©, ou √† la fin)
    box.addEventListener('dragover', (e)=>{
      if (!e.dataTransfer.types.includes(DND_MIME)) return;
      e.preventDefault(); e.stopPropagation();
      if (e.target.closest('.group-fields')) return; // pas ici : ce sera g√©r√© par le container du groupe
      box.classList.add('drop-target');
    });
    box.addEventListener('dragleave', (e)=>{
      e.stopPropagation();
      if (!e.currentTarget.contains(e.relatedTarget)) box.classList.remove('drop-target');
    });
    box.addEventListener('drop', (e)=>{
      if (!beginDrop(e)) return;
      box.classList.remove('drop-target');

      const overItem = e.target.closest('.field-item, .group-item');
      let beforeIdx = null;
      if (overItem && !overItem.closest('.group-fields')) {
        // Si on survole un item racine (champ ou groupe), on ins√®re avant lui
        beforeIdx = +overItem.dataset.index;
      }

      const raw = e.dataTransfer.getData(DND_MIME); if (!raw) { endDrop(); return; }
      const payload = JSON.parse(raw);

      // Corriger l‚Äôindex si on d√©place dans la m√™me liste apr√®s l‚Äôextraction
      if (beforeIdx!=null && payload.from==='root' &&
          payload.proc===currentProcess && payload.sec===currentSection){
        const isGrp = payload.kind==='group';
        const srcIdx = isGrp ? payload.gi : payload.fi;
        if (srcIdx < beforeIdx) beforeIdx -= 1;
      }

      const moved = takeItemFrom(payload); if (!moved) { endDrop(); return; }
      if (isGroup(moved)) insertGroupAtRoot(currentProcess, currentSection, moved, beforeIdx);
      else insertFieldAtRoot(currentProcess, currentSection, moved, beforeIdx);

      e.dataTransfer.dropEffect = 'move';
      markDrop(); endDrop();
    });

    box._dndBound = true;
  }

  (items||[]).forEach((it, idx)=>{
    if (isGroup(it)) {
      // ======= GROUPE RACINE =======
      const g = document.createElement('div');
      g.className = 'group-item'; g.dataset.index = idx; g.dataset.gid = it.__uid;
      g.draggable = true;
      g.innerHTML = `
        <div class="group-head">
          <input type="checkbox" class="select-box" data-kind="group" data-index="${idx}" title="S√©lectionner"/>
          <div class="group-title">${it.label || it.name || '(groupe)'}</div>
          <div class="group-meta pill">required: ${!!it.required} ‚Ä¢ repeatable: ${!!it.repeatable}</div>
          <div class="right">
            <button class="btn" data-act="up">‚¨ÜÔ∏è</button>
            <button class="btn" data-act="down">‚¨áÔ∏è</button>
            <button class="btn" data-act="edit">√âditer</button>
            <button class="btn danger" data-act="del">Supprimer</button>
          </div>
        </div>
        <div class="group-fields"></div>
      `;

      /* Drag du groupe (root only) */
      g.addEventListener('dragstart', (e)=>{
        g.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData(DND_MIME, JSON.stringify({
          kind:'group', from:'root', proc: currentProcess, sec: currentSection, gi: idx, gid: it.__uid
        }));
      });
      g.addEventListener('dragend', ()=> g.classList.remove('dragging'));

      /* D√©poser un ITEM (field ou group) avant ce groupe */
      g.addEventListener('dragover', (e)=>{
        if (!e.dataTransfer.types.includes(DND_MIME)) return;
        e.preventDefault(); e.stopPropagation();
        g.classList.add('drop-before');
      });
      g.addEventListener('dragleave', (e)=>{ e.stopPropagation(); g.classList.remove('drop-before'); });
      g.addEventListener('drop', (e)=>{
        if (!beginDrop(e)) return;
        g.classList.remove('drop-before');

        const raw = e.dataTransfer.getData(DND_MIME); if (!raw) { endDrop(); return; }
        const payload = JSON.parse(raw);

        // Prendre l‚Äôitem de sa source
        const moved = takeItemFrom(payload); if (!moved) { endDrop(); return; }

        // Destination = AVANT ce groupe
        const destProc = currentProcess;
        const destSec  = currentSection;
        let destIndex  = idx;
        // Ajuste si on vient de la m√™me liste
        if (payload.kind==='group' && payload.from==='root' &&
            payload.proc===destProc && payload.sec===destSec && payload.gi < destIndex){
          destIndex -= 1;
        }

        if (isGroup(moved)) {
          insertGroupAtRoot(destProc, destSec, moved, destIndex);
        } else if (isField(moved)) {
          insertFieldAtRoot(destProc, destSec, moved, destIndex);
        }

        e.dataTransfer.dropEffect = 'move';
        markDrop(); endDrop();
      });

      const inner = g.querySelector('.group-fields');

      // ======= CONTENEUR DU GROUPE (d√©poser un CHAMP √† l'int√©rieur, √† la fin) =======
      inner.addEventListener('dragover', (e)=>{
        if (!e.dataTransfer.types.includes(DND_MIME)) return;
        e.preventDefault(); e.stopPropagation();
        inner.classList.add('drop-target');
      });
      inner.addEventListener('dragleave', (e)=>{
        e.stopPropagation();
        if (!inner.contains(e.relatedTarget)) inner.classList.remove('drop-target');
      });
      inner.addEventListener('drop', (e)=>{
        if (!beginDrop(e)) return;
        inner.classList.remove('drop-target');

        const raw = e.dataTransfer.getData(DND_MIME); if (!raw) { endDrop(); return; }
        const payload = JSON.parse(raw);
        if (payload.kind !== 'field'){ endDrop(); return; } // pas de groupe dans un groupe

        const moved = takeItemFrom(payload); if (!moved || !isField(moved)) { endDrop(); return; }
        insertFieldInGroupByUid(g.dataset.gid, moved, null);

        e.dataTransfer.dropEffect = 'move';
        markDrop(); endDrop();
      });

      // ======= CHAMPS √Ä L‚ÄôINT√âRIEUR DU GROUPE =======
      (it.fields||[]).forEach((f, j)=>{
        const item = document.createElement('div');
        item.className = 'field-item'; item.draggable = true; item.dataset.index = `${idx}:${j}`;
        const optInfo = isOptType(f.type) ? ` <span class="muted">[${(f.options||[]).join(', ')}]</span>` : '';
        const hasTip = !!(f.tips && f.tips.text && f.tips.text.trim());
        const tipBadge = hasTip ? ' <span class="pill">Astuce</span>' : '';
        item.innerHTML = `
          <div class="drag" title="Glisser pour r√©organiser/d√©placer">‚ãÆ</div>
          <input type="checkbox" class="select-box" data-kind="field-in-group" data-index="${idx}:${j}" title="S√©lectionner"/>
          <div class="meta">
            <div><strong>${f.label || f.name || '(sans nom)'}</strong> <span class="muted">(${f.type})</span>${optInfo}${tipBadge}</div>
            <div class="muted">name: ${f.name || '‚Äî'} ‚Ä¢ required: ${!!f.required} ‚Ä¢ repeatable: ${!!f.repeatable}</div>
          </div>
          <div class="right">
            <button class="btn" data-act="up">‚¨ÜÔ∏è</button>
            <button class="btn" data-act="down">‚¨áÔ∏è</button>
            <button class="btn" data-act="edit">√âditer</button>
            <button class="btn danger" data-act="del">Supprimer</button>
          </div>`;

        // dragstart: champ en groupe
        item.addEventListener('dragstart', (e)=>{
          item.classList.add('dragging');
          e.dataTransfer.effectAllowed = 'move';
          e.dataTransfer.setData(DND_MIME, JSON.stringify({
            kind:'field', from:'group', proc: currentProcess, sec: currentSection, gi: idx, fi: j, gid: it.__uid
          }));
        });
        item.addEventListener('dragend', ()=> item.classList.remove('dragging'));

        // drop-before sur un champ de ce groupe (r√©ordonne dans ce groupe)
        item.addEventListener('dragover', (e)=>{
          if (!e.dataTransfer.types.includes(DND_MIME)) return;
          e.preventDefault(); e.stopPropagation();
          item.classList.add('drop-before');
        });
        item.addEventListener('dragleave', (e)=>{ e.stopPropagation(); item.classList.remove('drop-before'); });
        item.addEventListener('drop', (e)=>{
          if (!beginDrop(e)) return;
          item.classList.remove('drop-before');

          const raw = e.dataTransfer.getData(DND_MIME); if (!raw) { endDrop(); return; }
          const payload = JSON.parse(raw);
          if (payload.kind !== 'field'){ endDrop(); return; } // pas de groupe dans un groupe

          // destination: avant cet item J dans ce groupe
          let dest = j;
          if (payload.from === 'group' && payload.gid === it.__uid && payload.fi < dest) dest -= 1;

          const moved = takeItemFrom(payload); if (!moved || !isField(moved)) { endDrop(); return; }
          insertFieldInGroupByUid(it.__uid, moved, dest);

          e.dataTransfer.dropEffect = 'move';
          markDrop(); endDrop();
        });

        // Actions boutons
        item.addEventListener('click', (e)=>{
          if (isRecentDrop()) return;
          const act = e.target.closest('button')?.dataset?.act || 'edit';
          const arr = S()[currentSection].fields[idx].fields;
          if (act==='edit'){
            editingGroupIndex = idx; editingFieldIndex = j;
            openFieldEditor(arr[j]);
            renderPreview();
          } else if (act==='del'){
            if (confirm('Supprimer ce champ du groupe ?')){
              arr.splice(j,1); editingFieldIndex=-1; save(); renderAll(); selectSection(currentSection);
              toast('Champ supprim√©');
            }
          } else if (act==='up'){
            if (j>0){ const [m]=arr.splice(j,1); arr.splice(j-1,0,m); save(); renderAll(); selectSection(currentSection); }
          } else if (act==='down'){
            if (j<arr.length-1){ const [m]=arr.splice(j,1); arr.splice(j+1,0,m); save(); renderAll(); selectSection(currentSection); }
          }
        });

        inner.appendChild(item);
      });

      box.appendChild(g);
    } else {
      // ======= CHAMP RACINE =======
      const f = it;
      const item = document.createElement('div');
      item.className = 'field-item'; item.draggable = true; item.dataset.index = idx;
      const optInfo = isOptType(f.type) ? ` <span class="muted">[${(f.options||[]).join(', ')}]</span>` : '';
      const hasTip = !!(f.tips && f.tips.text && f.tips.text.trim());
      const tipBadge = hasTip ? ' <span class="pill">Astuce</span>' : '';
      item.innerHTML = `
        <div class="drag" title="Glisser pour r√©organiser/d√©placer">‚ãÆ</div>
        <input type="checkbox" class="select-box" data-kind="field-root" data-index="${idx}" title="S√©lectionner"/>
        <div class="meta">
          <div><strong>${f.label || f.name || '(sans nom)'}</strong> <span class="muted">(${f.type})</span>${optInfo}${tipBadge}</div>
          <div class="muted">name: ${f.name || '‚Äî'} ‚Ä¢ required: ${!!f.required} ‚Ä¢ repeatable: ${!!f.repeatable}</div>
        </div>
        <div class="right">
          <button class="btn" data-act="up">‚¨ÜÔ∏è</button>
          <button class="btn" data-act="down">‚¨áÔ∏è</button>
          <button class="btn" data-act="edit">√âditer</button>
          <button class="btn danger" data-act="del">Supprimer</button>
        </div>`;

      // dragstart: champ racine
      item.addEventListener('dragstart', (e)=>{
        item.classList.add('dragging');
        e.dataTransfer.effectAllowed = 'move';
        e.dataTransfer.setData(DND_MIME, JSON.stringify({
          kind:'field', from:'root', proc: currentProcess, sec: currentSection, fi: +item.dataset.index
        }));
      });
      item.addEventListener('dragend', ()=> item.classList.remove('dragging'));

      // drop-before (ins√©rer avant cet item racine)
      item.addEventListener('dragover', (e)=>{
        if (!e.dataTransfer.types.includes(DND_MIME)) return;
        e.preventDefault(); e.stopPropagation();
        item.classList.add('drop-before');
      });
      item.addEventListener('dragleave', (e)=>{ e.stopPropagation(); item.classList.remove('drop-before'); });
      item.addEventListener('drop', (e)=>{
        if (!beginDrop(e)) return;
        item.classList.remove('drop-before');

        const raw = e.dataTransfer.getData(DND_MIME); if (!raw) { endDrop(); return; }
        const payload = JSON.parse(raw);

        // destination: avant cet item
        let dest = +item.dataset.index;
        if (payload.from === 'root' &&
            payload.proc === currentProcess &&
            payload.sec  === currentSection) {
          const srcIdx = (payload.kind === 'group') ? payload.gi : payload.fi;
          if (srcIdx < dest) dest -= 1;
        }

        const moved = takeItemFrom(payload); if (!moved) { endDrop(); return; }
        if (isGroup(moved)) insertGroupAtRoot(currentProcess, currentSection, moved, dest);
        else insertFieldAtRoot(currentProcess, currentSection, moved, dest);

        e.dataTransfer.dropEffect = 'move';
        markDrop(); endDrop();
      });

      // Actions boutons
      item.addEventListener('click', (e)=>{
        if (isRecentDrop()) return;
        const act = e.target.closest('button')?.dataset?.act || 'edit';
        const arr = S()[currentSection].fields;
        if (act==='edit'){
          editingGroupIndex = -1; editingFieldIndex = idx;
          openFieldEditor(arr[idx]);
          renderPreview();
        } else if (act==='del'){
          if (confirm('Supprimer ce champ ?')){
            arr.splice(idx,1); editingFieldIndex=-1; save(); renderAll(); selectSection(currentSection);
            toast('Champ supprim√©');
          }
        } else if (act==='up'){
          if (idx>0){ const [m]=arr.splice(idx,1); arr.splice(idx-1,0,m); save(); renderAll(); selectSection(currentSection); }
        } else if (act==='down'){
          if (idx<arr.length-1){ const [m]=arr.splice(idx,1); arr.splice(idx+1,0,m); save(); renderAll(); selectSection(currentSection); }
        }
      });

      box.appendChild(item);
    }
  });
}

/* --- Export JSON --- */
function cleanItem(it){
  if (isGroup(it)){
    const g = { group:{
      name:(it.name||'').trim(),
      ...(it.label? {label:String(it.label).trim()} : {}),
      ...(it.required? {required:true} : {}),
      ...(it.repeatable? {repeatable:true} : {}),
    }};
    g.fields = (it.fields||[]).filter(isField).map(f=>{
      const out = { name:(f.name||'').trim(), type:f.type||'text' };
      if (f.label) out.label = String(f.label).trim();
      if (f.repeatable) out.repeatable = true;
      if (f.required) out.required = true;
      if (isOptType(f.type)) out.options = (f.options||[]).filter(x=>String(x).trim()!=='').map(String);
      if (f.tips && (String(f.tips.icon||'').trim() || String(f.tips.text||'').trim())){
        out.tips = {
          ...(f.tips.icon ? { icon: String(f.tips.icon) } : {}),
          ...(f.tips.text ? { text: String(f.tips.text) } : {})
        };
      }
      return out;
    });
    return g;
  }
  const out = { name:(it.name||'').trim(), type:it.type||'text' };
  if (it.label) out.label = String(it.label).trim();
  if (it.repeatable) out.repeatable = true;
  if (it.required) out.required = true;
  if (isOptType(it.type)) out.options = (it.options||[]).filter(x=>String(x).trim()!=='').map(String);
  if (it.tips && (String(it.tips.icon||'').trim() || String(it.tips.text||'').trim())){
    out.tips = {
      ...(it.tips.icon ? { icon: String(it.tips.icon) } : {}),
      ...(it.tips.text ? { text: String(it.tips.text) } : {})
    };
  }
  return out;
}
function getCleanModel(){
  return PROCESSES
    .filter(p=>p.enabled!==false)
    .map(p=>({
      name: (p.name||'').trim(),
      sections: (p.sections||[]).map(sec=>({
        title: (sec.title||'').trim(),
        fields: (sec.fields||[]).map(cleanItem)
      }))
    }));
}
function renderPreview(){
  const clean = getCleanModel();
  $('#jsonPreview').textContent = JSON.stringify(clean, null, 2);
  const procs = clean.length;
  const secs  = clean.reduce((a,p)=> a + (p.sections?.length||0), 0);
  const items = clean.reduce((a,p)=> a + (p.sections||[]).reduce((b,s)=> b + (s.fields?.length||0),0), 0);
  $('#countProcesses').textContent = procs + ' processus';
  $('#countSections').textContent  = secs  + ' partie' + (secs>1?'s':'');
  $('#countFields').textContent    = items + ' item' + (items>1?'s':'');
}

/* --- Ajouts --- */
function createSection(){
  const p = P(); if (!p) return;
  p.sections.push(makeSection());
  editingGroupIndex = -1; editingFieldIndex = -1;
  save(); renderAll(); selectSection(p.sections.length-1);
  toast('Partie ajout√©e');
}
function addNewField(){
  if (currentSection<0) createSection();
  const sec = S()[currentSection];
  const to = (editingGroupIndex>=0 && isGroup(sec.fields[editingGroupIndex]))
    ? sec.fields[editingGroupIndex].fields
    : (sec.fields || (sec.fields=[]));
  const f = makeField();
  f.label = '';
  f.name  = uniqueName(tinyName('champ'));
  to.push(f);
  editingFieldIndex = to.length - 1;
  $('#fldName').value=''; $('#fldLabel').value='';
  $('#fldType').value='text'; $('#fldRequired').value='false';
  $('#fldRepeatable').value='false'; $('#fldOptions').value='';
  $('#fldTipsIcon').value=''; $('#fldTips').value='';
  updateTipsPreview(f);
  updateOptionsVisibility();
  renderFields(sec.fields);
  $('#fldName').focus();
  save(); renderPreview(); toast('Champ ajout√©');
}
function bindAddButtons(){ $('#btnAddFieldTop').onclick = addNewField; $('#btnAddFieldSticky').onclick = addNewField; }
function updateOptionsVisibility(){ const t = $('#fldType').value; $('#rowOptions').style.display = isOptType(t) ? '' : 'none'; }
function groupSelected(){
  if (currentSection<0) return;
  const sec = S()[currentSection]; const arr = sec.fields || (sec.fields=[]);
  const selected = $$('.select-box[data-kind="field-root"]:checked').map(cb => +cb.dataset.index).sort((a,b)=>a-b);
  if (selected.length < 1){ toast('S√©lectionne au moins un champ racine'); return; }
  const group = makeGroup(); group.label = 'Nouveau groupe'; group.name = uniqueName(tinyName(group.label || 'groupe'));
  const moved = [];
  for (let i = selected.length-1; i>=0; i--){ const idx = selected[i]; const it = arr[idx]; if (isField(it)) { moved.unshift(it); arr.splice(idx,1); } }
  if (moved.length===0){ toast('Aucun champ racine s√©lectionn√©'); return; }
  group.fields = moved; arr.push(group);
  save(); renderAll(); selectSection(currentSection); toast('Champs regroup√©s');
}

/* --- Validation import --- */
function validateTemplate(tpl){
  if (!Array.isArray(tpl)) return { valid:false, reason:'Racine non tableau (processus[])' };
  for (let i=0;i<tpl.length;i++){
    const p = tpl[i] || {};
    if (typeof p !== 'object') return { valid:false, reason:`processus[${i}] non objet` };
    if (!('name' in p)) return { valid:false, reason:`processus[${i}] sans "name"` };
    if (!Array.isArray(p.sections)) return { valid:false, reason:`processus[${i}].sections doit √™tre un tableau` };
    for (let s=0;s<p.sections.length;s++){
      const sec = p.sections[s] || {};
      if (typeof sec !== 'object') return { valid:false, reason:`sections[${s}] non objet` };
      if (!('title' in sec)) return { valid:false, reason:`sections[${s}] sans "title"` };
      if (sec.fields && !Array.isArray(sec.fields)) return { valid:false, reason:`sections[${s}].fields doit √™tre un tableau` };
      const fields = sec.fields || [];
      for (let j=0;j<fields.length;j++){
        const f = fields[j] || {};
        const isGrp = ('group' in f) && typeof f.group === 'object' && Array.isArray(f.fields);
        const isFld = ('name' in f) && ('type' in f);
        if (!isGrp && !isFld) return { valid:false, reason:`fields[${j}] doit √™tre un champ (name/type) ou un groupe (group/fields)` };
        if (isFld && (f.type==='radio'||f.type==='select') && f.options && !Array.isArray(f.options))
          return { valid:false, reason:`fields[${j}].options doit √™tre un tableau` };
        if (isGrp){
          for (let k=0;k<f.fields.length;k++){
            const gch = f.fields[k] || {};
            if (!gch.name) return { valid:false, reason:`group.fields[${k}] sans "name"` };
            if (!gch.type) return { valid:false, reason:`group.fields[${k}] sans "type"` };
            if ((gch.type==='radio'||gch.type==='select') && gch.options && !Array.isArray(gch.options))
              return { valid:false, reason:`group.fields[${k}].options doit √™tre un tableau` };
          }
        }
      }
    }
  }
  return { valid:true };
}

/* --- Bind inputs (live) --- */
function bindFieldInputsLive(){
  const map = {
    '#fldName': (el, f)=>{
      const label = el.value || '';
      f.label = label;
      $('#fldLabel').value = label;
      if (f.nameAuto !== false){
        const base = tinyName(label || 'champ');
        f.name = uniqueName(base);
      }
    },
    '#fldLabel': (el, f)=>{
      const label = el.value || '';
      f.label = label;
      $('#fldName').value = label;
      if (f.nameAuto !== false){
        const base = tinyName(label || 'champ');
        f.name = uniqueName(base);
      }
    },
    '#fldType': (el, f)=>{ f.type = el.value; if(!isOptType(f.type)) f.options = []; updateOptionsVisibility(); },
    '#fldRequired': (el, f)=>{ f.required = (el.value==='true'); },
    '#fldRepeatable':(el, f)=>{ f.repeatable = (el.value==='true'); },
    '#fldOptions':   (el, f)=>{ f.options = el.value.split(',').map(s=>s.trim()).filter(Boolean); },
    // Tips
    '#fldTipsIcon': (el, f)=>{ f.tips = f.tips || {icon:'',text:''}; f.tips.icon = el.value; updateTipsPreview(f); },
    '#fldTips':     (el, f)=>{ f.tips = f.tips || {icon:'',text:''}; f.tips.text = el.value; updateTipsPreview(f); }
  };

  Object.entries(map).forEach(([sel, apply])=>{
    const el = document.querySelector(sel); if (!el) return;
    const evt = (sel==='#fldType' || sel==='#fldRequired' || sel==='#fldRepeatable') ? 'change' : 'input';
    el.addEventListener(evt, ()=>{
      if (currentSection<0) createSection();
      const sec = S()[currentSection];
      let f;
      if (editingGroupIndex>=0 && isGroup(sec.fields?.[editingGroupIndex])){
        const g = sec.fields[editingGroupIndex];
        if (editingFieldIndex < 0){ (g.fields||(g.fields=[])).push(makeField()); editingFieldIndex = g.fields.length - 1; }
        f = g.fields[editingFieldIndex];
      } else {
        if (editingFieldIndex < 0){ (sec.fields||(sec.fields=[])).push(makeField()); editingFieldIndex = sec.fields.length - 1; }
        f = sec.fields[editingFieldIndex];
      }
      apply(el, f);
      save(); renderPreview(); refreshFieldUI();
    });
  });

  // Groupes
  const groupMap = {
    '#grpLabel': (el, g)=>{
      g.label = el.value;
      if (g.nameAuto){
        const base = tinyName(g.label || 'groupe');
        g.name = uniqueName(base);
        $('#grpName').value = g.name;
      }
    },
    '#grpName': (el, g)=>{
      g.nameAuto = false;
      const base = tinyName(el.value || g.label || 'groupe');
      g.name = uniqueName(base);
      el.value = g.name;
    },
    '#grpRequired':  (el, g)=>{ g.required  = (el.value==='true'); },
    '#grpRepeatable':(el, g)=>{ g.repeatable= (el.value==='true'); }
  };
  Object.entries(groupMap).forEach(([sel, apply])=>{
    const el = document.querySelector(sel); if (!el) return;
    const evt = (sel==='#grpRequired' || sel==='#grpRepeatable') ? 'change' : 'input';
    el.addEventListener(evt, ()=>{
      if (currentSection<0 || editingGroupIndex<0) return;
      const g = S()[currentSection].fields?.[editingGroupIndex]; if (!isGroup(g)) return;
      apply(el, g);
      save(); renderPreview(); renderFields(S()[currentSection].fields);
    });
  });

  $('#btnDeleteGroup').addEventListener('click', ()=>{
    if (currentSection<0 || editingGroupIndex<0) return;
    S()[currentSection].fields.splice(editingGroupIndex,1);
    editingGroupIndex = -1;
    save(); renderAll(); selectSection(currentSection);
  });
}

/* --- Icon picker setup --- */
const ICONS = ["üí°","‚ÑπÔ∏è","üìå","üìé","‚úÖ","‚ö†Ô∏è","üö´","üìù","üß†","üß©","üîó","üìÇ","üìÑ","üì£","üïí","üß™","üí¨","üß∑","üîç","üì∑","üñáÔ∏è","üì¶","üóÇÔ∏è","üß≠","üìö","üßæ","üßØ","üéØ","üõ†Ô∏è","üß±","ü™™","üß∑","üíæ","üßë‚Äçüè´","üè∑Ô∏è","ü™Ñ","üí≠","üöÄ"];
function buildIconPicker(){
  const grid = $('#iconGrid'); if (!grid) return;
  grid.innerHTML = '';
  ICONS.forEach(ic=>{
    const b = document.createElement('button');
    b.type = 'button'; b.textContent = ic;
    b.addEventListener('click', ()=>{
      const inp = $('#fldTipsIcon');
      inp.value = ic; inp.dispatchEvent(new Event('input', {bubbles:true}));
      grid.classList.add('hidden');
    });
    grid.appendChild(b);
  });
  const dl = $('#iconDatalist');
  if (dl){ dl.innerHTML = ICONS.map(i=>`<option value="${i}">`).join(''); }
  $('#btnToggleIconPicker')?.addEventListener('click', ()=>{
    grid.classList.toggle('hidden');
  });
  document.addEventListener('click', (e)=>{
    if (!grid.contains(e.target) && e.target !== $('#btnToggleIconPicker')){
      grid.classList.add('hidden');
    }
  });
}

/* --- Global render --- */
function renderAll(){ renderProcesses(); renderSections(); renderPreview(); }

/* --- Bind global --- */
function bindGlobal(){
  $('#btnNewProcess').addEventListener('click', ()=>{
    PROCESSES.push(makeProcess());
    currentProcess = PROCESSES.length-1; currentSection=-1;
    save(); renderAll(); selectProcess(currentProcess); toast('Processus ajout√©');
  });
  $('#fabAdd').addEventListener('click', ()=> $('#btnNewProcess').click());
  $('#btnNewSection').addEventListener('click', createSection);

  $('#btnDeleteSection').addEventListener('click', ()=>{
    if (currentSection<0) return;
    const sections = S();
    if (!confirm('Supprimer cette partie et tous ses items ?')) return;
    sections.splice(currentSection,1);
    save(); renderAll(); selectSection(-1); toast('Partie supprim√©e');
  });

  $('#btnFieldUp').addEventListener('click', ()=>{
    if (currentSection<0) return;
    const sec = S()[currentSection];
    if (editingGroupIndex>=0 && editingFieldIndex>=0 && isGroup(sec.fields[editingGroupIndex])){
      const arr = sec.fields[editingGroupIndex].fields; const i = editingFieldIndex;
      if (i>0){ const [m]=arr.splice(i,1); arr.splice(i-1,0,m); editingFieldIndex=i-1; save(); renderFields(sec.fields); renderPreview(); }
      return;
    }
    if (editingFieldIndex<0) return;
    const arr = sec.fields; const i = editingFieldIndex;
    if (i>0){ const [m]=arr.splice(i,1); arr.splice(i-1,0,m); editingFieldIndex=i-1; save(); renderFields(arr); renderPreview(); }
  });

  $('#btnFieldDown').addEventListener('click', ()=>{
    if (currentSection<0) return;
    const sec = S()[currentSection];
    if (editingGroupIndex>=0 && editingFieldIndex>=0 && isGroup(sec.fields[editingGroupIndex])){
      const arr = sec.fields[editingGroupIndex].fields; const i = editingFieldIndex;
      if (i < arr.length-1){ const [m]=arr.splice(i,1); arr.splice(i+1,0,m); editingFieldIndex=i+1; save(); renderFields(sec.fields); renderPreview(); }
      return;
    }
    if (editingFieldIndex<0) return;
    const arr = sec.fields; const i = editingFieldIndex;
    if (i < arr.length-1){ const [m]=arr.splice(i,1); arr.splice(i+1,0,m); editingFieldIndex=i+1; save(); renderFields(arr); renderPreview(); }
  });

  // (REMPLACE) Export JSON -> chiffr√© AES-GCM
  $('#btnExport').addEventListener('click', async ()=>{
    const pwd = await promptPassword('Exporter JSON (prot√©g√©)', "Entrez un mot de passe pour chiffrer l'export.");
    if (!pwd) return;
    const clean = getCleanModel();
    const payload = await aesGcmEncryptFromString(pwd, JSON.stringify(clean, null, 2));
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'template.processes.enc.json';
    document.body.appendChild(a); a.click(); URL.revokeObjectURL(a.href); a.remove();
    toast('JSON chiffr√© export√© ‚úÖ');
  });

  // (REMPLACE) Copie en clair avec avertissement explicite
  $('#btnCopy').addEventListener('click', async ()=>{
    const ok = await confirmWarning(
      'Copier le JSON en clair',
      "Vous allez copier le mod√®le en clair dans le presse-papiers. √âvitez de le coller dans des outils non s√ªrs.",
      'Copier quand m√™me'
    );
    if (!ok) return;
    const clean = getCleanModel();
    await navigator.clipboard.writeText(JSON.stringify(clean, null, 2));
    toast('JSON copi√© (en clair) ‚úÖ');
  });

  // (REMPLACE) Import JSON -> d√©tecte chiffrage et demande le mot de passe
  $('#fileImport').addEventListener('change', async (e)=>{
    const f = e.target.files?.[0]; if (!f) return;
    try{
      const txt = await f.text();
      let json = JSON.parse(txt);

      // D√©tection enveloppe chiffr√©e
      if (json && json.format === 'IF-AESGCM-v1' && json.ct && json.iv && json.salt){
        const pwd = await promptPassword('Importer JSON (prot√©g√©)', 'Saisissez le mot de passe du fichier.');
        if (!pwd) throw new Error('Import annul√©');
        const plain = await aesGcmDecryptToString(pwd, json);
        json = JSON.parse(plain);
      }

      // Compat legacy: si root = sections[] -> wrap en processus
      if (Array.isArray(json) && json.length && !('sections' in (json[0]||{})) && ('title' in (json[0]||{}))){
        json = [{ name:'Processus 1', enabled:true, sections: json }];
      }

      const ok = validateTemplate(json);
      if (!ok.valid) throw new Error('Mod√®le invalide : ' + ok.reason);

      PROCESSES = json.map(p=>({
        name: p.name || 'Processus',
        enabled: (p.enabled!==false),
        sections: (p.sections||[]).map(sec=>{
          const s = { title: sec.title || '', fields: [] };
          s.fields = (sec.fields||[]).map(it=>{
            if (it.group){
              const g = {
                __kind:'group',
                __uid: genUid(),
                name: it.group.name || tinyName(it.group.label || 'groupe'),
                label: it.group.label || '',
                required: !!it.group.required,
                repeatable: !!it.group.repeatable,
                nameAuto: false,
                fields: (it.fields||[]).map(f=>{
                  const ff = { __kind:'field', ...f, nameAuto:false };
                  if (!ff.name) ff.name = tinyName(ff.label || ff.name || 'champ');
                  if (!ff.tips) ff.tips = { icon:'', text:'' };
                  return ff;
                })
              };
              return g;
            }
            const f2 = { __kind:'field', ...it, nameAuto:false };
            if (!f2.name) f2.name = tinyName(f2.label || f2.name || 'champ');
            if (!f2.tips) f2.tips = { icon:'', text:'' };
            return f2;
          });
          return s;
        })
      }));
      currentProcess = 0; currentSection = PROCESSES[0]?.sections?.length ? 0 : -1;
      save(); renderAll(); selectProcess(currentProcess); if (currentSection>=0) selectSection(currentSection);
      toast('Mod√®le import√©');
    }catch(err){ alert('Import √©chou√© : ' + (err?.message || err)); }
    finally{ e.target.value=''; }
  });

  $('#btnAddGroup').addEventListener('click', ()=>{
    if (currentSection<0) createSection();
    const sec = S()[currentSection];
    const arr = sec.fields || (sec.fields=[]);
    const g = makeGroup(); g.label = ''; g.name = uniqueName(tinyName('groupe'));
    arr.push(g);
    save(); renderAll(); selectSection(currentSection);
    toast('Groupe ajout√©');
  });

  $('#btnGroupSelected')?.addEventListener('click', groupSelected);
  
  $('#btnUmlZip')?.addEventListener('click', exportAllUmlZIP);


  $('#btnAddFieldInGroup').addEventListener('click', ()=>{
    if (currentSection<0 || editingGroupIndex<0) return;
    const g = S()[currentSection].fields[editingGroupIndex];
    (g.fields || (g.fields=[])).push(makeField());
    const base = tinyName('champ');
    g.fields[g.fields.length-1].name = uniqueName(base);
    editingFieldIndex = g.fields.length - 1;
    renderFields(S()[currentSection].fields);
    save(); renderPreview();
  });

  // Prot√©ger les checkboxes des clics de carte
  (function protectCheckboxes(){
    const area = document.getElementById('fieldList'); if (!area) return;
    const stop = e => { if (e.target && e.target.matches('input[type="checkbox"]')) e.stopPropagation(); };
    area.addEventListener('mousedown', stop, true);
    area.addEventListener('click', stop, true);
  })();

  buildIconPicker();
}

/* --- Assure UID + tips --- */
function ensureGroupUids(){
  PROCESSES.forEach(p=>{
    (p.sections||[]).forEach(sec=>{
      (sec.fields||[]).forEach(it=>{
        if (isGroup(it) && !it.__uid) it.__uid = genUid();
      });
    });
  });
}

/* === Export UML: ZIP (SVG + PNG par process) ‚Äî sans d√©pendance === */

/* Utilitaire: nom de fichier safe */
function safeName(s){ return String(s||'processus').replace(/[^\p{L}\p{N}\-_.]+/gu,'_'); }

/* Refactor: version ‚Äúpour un process donn√©‚Äù */
function generateUmlSVGFor(proc){
  if (!proc) return '';
  const sections = (proc.sections||[]);
  // couleurs (reprend CSS vars)
  const css = getComputedStyle(document.documentElement);
  const W = 1200, PAD = 24, COLW = W - PAD*2, BOXR = 12;
  const BG = css.getPropertyValue('--bg') || '#f6f7fb';
  const FG = css.getPropertyValue('--fg') || '#111827';
  const PANEL = css.getPropertyValue('--panel') || '#ffffff';
  const BORDER = css.getPropertyValue('--card-border') || '#e5e7eb';
  const ACCENT = css.getPropertyValue('--accent') || '#2563eb';
  const MUTED = css.getPropertyValue('--muted') || '#6b7280';

  const meas = document.createElement('canvas'); const m = meas.getContext('2d');
  const F_PROC = '600 24px Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial';
  const F_SEC  = '700 18px Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial';
  const F_TXT  = '14px Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial';
  const LINE   = 20;

  const wrap=(t,max,f)=>{ m.font=f; const w=String(t||'').split(/\s+/); const out=[]; let cur=''; 
    for(const word of w){ const test=cur?cur+' '+word:word; if(m.measureText(test).width<=max) cur=test; else{ if(cur) out.push(cur); cur=word; } } 
    if(cur) out.push(cur); return out.length?out:['']; };
  const esc=s=>String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');

  // nodes
  const nodes = [{ kind:'start', title:'Start', w:260, h:40 }];
  sections.forEach((sec, si)=>{
    const contentW = COLW - 32;
    const titleLines = wrap(sec.title || '(section)', contentW, F_SEC);
    let innerH = titleLines.length*LINE + 8;
    const items=[];
    (sec.fields||[]).forEach(it=>{
      if (isGroup(it)){
        const head = `Groupe: ${it.label || it.name || '(groupe)'}  ‚Ä¢ req:${!!it.required} ‚Ä¢ rep:${!!it.repeatable}`;
        items.push({t:head, type:'group-head'});
        (it.fields||[]).forEach(f=>{
          const opts=(isOptType(f.type)&&Array.isArray(f.options)&&f.options.length)?` [${f.options.join(', ')}]`:'';
          const tip =(f.tips&&f.tips.text&&f.tips.text.trim())?' ‚Ä¢ üí°':'';
          items.push({t:`‚Ä¢ ${f.label || f.name || '(champ)'} (${f.type}) ‚Ä¢ req:${!!f.required} ‚Ä¢ rep:${!!f.repeatable}${opts}${tip}`, type:'group-item'});
        });
        items.push({t:'',type:'spacer'});
      }else{
        const f=it;
        const opts=(isOptType(f.type)&&Array.isArray(f.options)&&f.options.length)?` [${f.options.join(', ')}]`:'';
        const tip =(f.tips&&f.tips.text&&f.tips.text.trim())?' ‚Ä¢ üí°':'';
        items.push({t:`‚Ä¢ ${f.label || f.name || '(champ)'} (${f.type}) ‚Ä¢ req:${!!f.required} ‚Ä¢ rep:${!!f.repeatable}${opts}${tip}`, type:'field'});
      }
    });
    items.forEach(l=>{ const ls=wrap(l.t, contentW, F_TXT); l._lines=ls; innerH += (ls.length||1)*LINE + (l.type==='spacer'?8:0); });
    nodes.push({ kind:'section', titleLines, items, w:COLW, h:innerH+32, index:si });
  });
  nodes.push({ kind:'end', title:'End', w:260, h:40 });

  // mesure en-t√™te
  const procLines = wrap(proc.name || '(processus)', COLW, F_PROC);
  const subtitle = `${sections.length} partie(s) ‚Ä¢ export: ${new Date().toLocaleString()}`;
  const subLines = wrap(subtitle, COLW, 'italic 13px Inter,system-ui');
  const headerH = procLines.length*LINE + 8 + subLines.length*LINE + 10;

  // hauteur totale
  const GAP=24; let nodesSum=0; nodes.forEach(n=>nodesSum+=n.h+GAP); nodesSum-=GAP;
  const totalH = PAD + headerH + nodesSum + PAD;

  // helpers svg
  const rect=(x,y,w,h,r,fill,stroke)=>`<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="${r}" ry="${r}" fill="${fill}" stroke="${stroke}" filter="url(#cardShadow)"/>`;
  const textLines=(x, yTop, lines, font, fill)=>{ let out='', ycur=yTop; for(const ln of lines){ out+=`<text x="${x}" y="${ycur}" font="${font}" fill="${fill}">${esc(ln)}</text>`; ycur+=LINE; } return out; };

  // build svg
  let y=PAD, out=[];
  out.push(`<svg xmlns="http://www.w3.org/2000/svg" width="${W}" height="${totalH}" viewBox="0 0 ${W} ${totalH}">
  <defs>
    <marker id="arrow" viewBox="0 0 10 10" refX="9" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
      <path d="M 0 0 L 10 5 L 0 10 z" fill="${ACCENT.trim()||'#2563eb'}"></path>
    </marker>
    <filter id="cardShadow" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="0" dy="2" stdDeviation="2" flood-color="#000" flood-opacity="0.08"/>
    </filter>
  </defs>
  <rect x="0" y="0" width="${W}" height="${totalH}" fill="${(BG||'#f6f7fb').trim()}"/>`);

  out.push(textLines(PAD, y+22, procLines, F_PROC, (FG||'#111827').trim())); y += procLines.length*LINE + 8;
  out.push(textLines(PAD, y+16, subLines, 'italic 13px Inter,system-ui', (MUTED||'#6b7280').trim())); y += subLines.length*LINE + 10;

  let prevX = PAD + COLW/2, prevY = y;
  nodes.forEach((n, idx)=>{
    if (n.kind==='start' || n.kind==='end'){
      const nx = PAD + (COLW - n.w)/2, ny=y;
      out.push(rect(nx, ny, n.w, n.h, 20, (ACCENT||'#2563eb').trim(), (ACCENT||'#2563eb').trim()));
      out.push(`<text x="${nx+n.w/2}" y="${ny+n.h/2+5}" text-anchor="middle" font="700 14px Inter,system-ui" fill="#fff">${n.title}</text>`);
      if (idx>0) out.push(`<line x1="${prevX}" y1="${prevY}" x2="${PAD+COLW/2}" y2="${ny}" stroke="${(ACCENT||'#2563eb').trim()}" stroke-width="2" marker-end="url(#arrow)"/>`);
      y += n.h + GAP; prevX = PAD+COLW/2; prevY = ny+n.h; return;
    }
    const nx=PAD, ny=y; out.push(rect(nx, ny, n.w, n.h, BOXR, (PANEL||'#fff').trim(), (BORDER||'#e5e7eb').trim()));
    const innerX = nx+16, innerY0 = ny+16;
    out.push(textLines(innerX, innerY0+18, n.titleLines, F_SEC, (ACCENT||'#2563eb').trim()));
    let yy = innerY0 + n.titleLines.length*LINE + 8;
    n.items.forEach(it=>{
      const color = it.type==='group-item' ? (MUTED||'#6b7280').trim() : (FG||'#111827').trim();
      const lines = it._lines && it._lines.length ? it._lines : [''];
      out.push(textLines(innerX, yy+16, lines, F_TXT, color));
      yy += lines.length*LINE + (it.type==='spacer'?8:0);
    });
    out.push(`<line x1="${prevX}" y1="${prevY}" x2="${PAD+COLW/2}" y2="${ny}" stroke="${(ACCENT||'#2563eb').trim()}" stroke-width="2" marker-end="url(#arrow)"/>`);
    y += n.h + GAP; prevX = PAD+COLW/2; prevY = ny+n.h;
  });

  out.push(`</svg>`);
  return out.join('\n');
}

/* Convertit SVG texte -> PNG Blob */
function svgTextToPngBlob(svgText){
  return new Promise((resolve, reject)=>{
    const img = new Image();
    const url = URL.createObjectURL(new Blob([svgText], {type:'image/svg+xml'}));
    img.onload = ()=>{
      const c = document.createElement('canvas'); c.width = img.width; c.height = img.height;
      const ctx = c.getContext('2d'); ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,c.width,c.height); ctx.drawImage(img,0,0);
      URL.revokeObjectURL(url);
      c.toBlob(b=> b?resolve(b):reject(new Error('PNG fail')), 'image/png', 1);
    };
    img.onerror = ()=>{ URL.revokeObjectURL(url); reject(new Error('SVG load fail')); };
    img.src = url;
  });
}

/* === Mini ZIP (store only) ‚Äî CRC32 + headers === */
const CRC32_TABLE = (()=>{ let c, t=new Uint32Array(256); for(let n=0;n<256;n++){ c=n; for(let k=0;k<8;k++){ c = (c&1)? (0xEDB88320 ^ (c>>>1)) : (c>>>1); } t[n]=c>>>0; } return t; })();
function crc32(u8){ let c=~0>>>0; for(let i=0;i<u8.length;i++){ c = CRC32_TABLE[(c^u8[i])&0xFF] ^ (c>>>8); } return (~c)>>>0; }
function dosDateTime(d=new Date()){
  const dt = new Date(d);
  const year = Math.max(1980, dt.getFullYear());
  const dosDate = ((year-1980)<<9) | ((dt.getMonth()+1)<<5) | dt.getDate();
  const dosTime = (dt.getHours()<<11) | (dt.getMinutes()<<5) | Math.floor(dt.getSeconds()/2);
  return {dosDate, dosTime};
}
function strToU8(s){ return new TextEncoder().encode(s); }
function u32le(n){ return new Uint8Array([n&255,(n>>>8)&255,(n>>>16)&255,(n>>>24)&255]); }
function u16le(n){ return new Uint8Array([n&255,(n>>>8)&255]); }

async function makeZip(files){ // files: [{name, data: Uint8Array, date?:Date}]
  // concat helper
  const chunks=[]; let offset=0;
  const central=[]; let centralSize=0;
  const push=(u8)=>{ chunks.push(u8); offset+=u8.length; };
  for(const f of files){
    const nameU8 = strToU8(f.name);
    const dataU8 = f.data;
    const {dosDate,dosTime} = dosDateTime(f.date);
    const crc = crc32(dataU8);
    const localHeader = new Uint8Array([
      ...u32le(0x04034b50), ...u16le(20), ...u16le(0), ...u16le(0), ...u16le(dosTime), ...u16le(dosDate),
      ...u32le(crc), ...u32le(dataU8.length), ...u32le(dataU8.length),
      ...u16le(nameU8.length), ...u16le(0)
    ]);
    push(localHeader); push(nameU8); push(dataU8);
    // central dir entry
    const centralHeader = new Uint8Array([
      ...u32le(0x02014b50), ...u16le(20), ...u16le(20), ...u16le(0), ...u16le(0), ...u16le(dosTime), ...u16le(dosDate),
      ...u32le(crc), ...u32le(dataU8.length), ...u32le(dataU8.length),
      ...u16le(nameU8.length), ...u16le(0), ...u16le(0),
      ...u16le(0), ...u16le(0), ...u32le(0), ...u32le(offset - (localHeader.length + nameU8.length + dataU8.length))
    ]);
    central.push(centralHeader, nameU8);
    centralSize += centralHeader.length + nameU8.length;
  }
  const centralStart = offset;
  for(const part of central) push(part);
  const end = new Uint8Array([
    ...u32le(0x06054b50), ...u16le(0), ...u16le(0),
    ...u16le(files.length), ...u16le(files.length),
    ...u32le(centralSize), ...u32le(centralStart),
    ...u16le(0)
  ]);
  push(end);
  // merge chunks into one Uint8Array and Blob
  let total=0; chunks.forEach(c=>total+=c.length);
  const out = new Uint8Array(total); let p=0; for(const c of chunks){ out.set(c,p); p+=c.length; }
  return new Blob([out], {type:'application/zip'});
}

// (AJOUT) ZIP AES (7-Zip/WinZip) avec zip.js
async function makeZipAES(files, password){
  if (!window.zip) throw new Error('zip.js introuvable');
  const writer = new zip.ZipWriter(new zip.BlobWriter('application/zip'), {
    password,               // active AES
    encryptionStrength: 3,  // AES-256
    zipCrypto: false,       // pas de PKZip legacy
    level: 0                // pas de compression (plus rapide, optionnel)
  });
  for (const f of files){
    await writer.add(
      f.name,
      new zip.Uint8ArrayReader(f.data),
      { lastModDate: f.date || new Date() }
    );
  }
  return await writer.close();
}

/* Build ZIP de tous les processus activ√©s */
/* (REMPLACE) Build ZIP UML prot√©g√© AES */
async function exportAllUmlZIP(){
  const procs = PROCESSES.filter(p=>p.enabled!==false);
  if (!procs.length){ alert('Aucun processus activ√©'); return; }

  const pwd = await promptPassword('Sch√©ma UML (ZIP prot√©g√©)', 'Choisissez un mot de passe pour le ZIP.');
  if (!pwd) return;

  const files = [];
  for (const p of procs){
    const svg = generateUmlSVGFor(p);
    const base = safeName(p.name||'processus');
    // SVG
    const svgU8 = strToU8(svg);
    files.push({ name: `${base}.uml.svg`, data: svgU8, date:new Date() });
    // PNG
    const pngBlob = await svgTextToPngBlob(svg);
    const buf = new Uint8Array(await pngBlob.arrayBuffer());
    files.push({ name: `${base}.uml.png`, data: buf, date:new Date() });
  }

  let zipBlob;
  try{
    zipBlob = await makeZipAES(files, pwd);    // << chiffrage AES
  }catch(e){
    // Fallback (non chiffr√©) si zip.js indispo
    console.warn('zip.js indisponible, fallback non chiffr√©', e);
    zipBlob = await makeZip(files);            // << store only (non prot√©g√©)
  }
  const zipUrl = URL.createObjectURL(zipBlob);
  const name = `uml_exports_${new Date().toISOString().replace(/[:.]/g,'-')}.zip`;
  const a = document.createElement('a'); a.href = zipUrl; a.download = name; document.body.appendChild(a); a.click(); a.remove();
  URL.revokeObjectURL(zipUrl);
  toast('ZIP UML export√© (prot√©g√©) ‚úÖ');
}

/* --- Boot --- */
function boot(){
  PROCESSES = load();
  if (!Array.isArray(PROCESSES) || !PROCESSES.length){
    PROCESSES = [ makeProcess() ];
  }
  // normalise
  PROCESSES.forEach(p=>{
    if (typeof p.enabled === 'undefined') p.enabled = true;
    if (!Array.isArray(p.sections)) p.sections = [];
    p.sections = p.sections.map(sec=>{
      sec.fields = (sec.fields||[]).map(it=>{
        if (it.group){
          const g = {
            __kind:'group',
            __uid: it.__uid || genUid(),
            name: (it.group.name||tinyName(it.group.label||'groupe')),
            label: (it.group.label||''),
            required: !!it.group.required,
            repeatable: !!it.group.repeatable,
            nameAuto: false,
            fields: (it.fields||[]).map(f=>{
              const ff = { __kind:'field', ...f, nameAuto:false };
              if (!ff.name) ff.name = tinyName(ff.label || ff.name || 'champ');
              if (!ff.tips) ff.tips = { icon:'', text:'' };
              return ff;
            })
          };
          return g;
        }
        if (it.__kind==='group' || it.__kind==='field'){
          if (isGroup(it) && !it.__uid) it.__uid = genUid();
          if (isField(it) && !it.tips) it.tips = { icon:'', text:'' };
          return it;
        }
        const f = { __kind:'field', ...it, nameAuto:false };
        if (!f.name) f.name = tinyName(f.label || f.name || 'champ');
        if (!f.tips) f.tips = { icon:'', text:'' };
        return f;
      });
      return sec;
    });
  });
  ensureGroupUids();
  if (currentProcess>=PROCESSES.length) currentProcess=0;
  renderAll();
  selectProcess(currentProcess);
  if (S().length) selectSection(0); else selectSection(-1);
  updateOptionsVisibility();
  bindFieldInputsLive();
}

/* --- Fit header height for full-height layout --- */
(function fitHeader(){
  const set = ()=> {
    const h = document.querySelector('header')?.offsetHeight || 64;
    document.documentElement.style.setProperty('--header-h', h + 'px');
  };
  set();
  window.addEventListener('resize', set);
  window.addEventListener('load', set);
})();

/* --- Init --- */
(function init(){
  bindGlobal();
  boot();
})();

</script>
</body>
</html>
